{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PVGeo \u00b6 PVGeo is a Python package that contains VTK powered tools for data visualization in geophysics which are wrapped for direct use within the application ParaView by Kitware . These tools are tailored to data visualization in the geosciences with a heavy focus on structured data sets like 2D or 3D time-varying grids. On this website, we provide several examples and tutorials of how to use PVGeo in a python environment as well as how to use the ParaView plugins delivered along side the python package for common tasks in the visualization of geoscientific data. Feel free to join the PVGeo community on Slack to keep up with new features and for any help using the code library and follow us on Twitter to keep up: Follow @OpenGeoVis Suggestions? If you have an idea for a file reader, data filter, ParaView plugin, or would like to see how we would address a geoscientific visualization problem with ParaView, please post your thoughts on the issues page or become involved with the PVGeo community discussions on Slack . How to use PVGeo To download and use the PVGeo code library, follow the installation instructions on the Getting Started Page . If you are interested in development, all code is published on the GitHub repository PVGeo linked to this page. Click the \u2018PVGeo on GitHub\u2019 link on the right side of the menu bar at the top to find all of the code or you can follow this link . Also take a look at the Development Guide How to explore this documentation On a Desktop: There are six main sections to this website shown in the navigation tab at the top of the page. Use these tabs to explore the different aspects of the project! Use the sidebar to the right to explore the contents of the current page and use the sidebar to the left to find all the different pages for this active section/tab. Here is a list of the available sections: Overview: An introduction to the project with installation details on how to get started. Examples: A guide to all of the plugins we have implemented for use directly in ParaView. This section has all the information you will need to understand how to use our plugins and how we group them together into what we call suites . This section has high level explanations and examples while the docs website has the code documentation. Docs: This tab will forward you to the code docs website PV Macros: A guide on how to use all of the macros developed in the pvmacros module. Resources: A conglomerate of additional resources that are helpful when using ParaView and VTK for geoscientific applications. Development Guide: This is an all encompassing guid on how to start making your own plugins as well as how to contribute to the PVGeo repository. Web renderings not working? If the web renderings like the one below in the demo section of this page are not working, then please make sure to enable javascript in your web browser. Demo \u00b6 Check out the Demo Page to see video demos and interactive demos like the scene below. This is an example of three data sets visually integrated using our framework within ParaView then exported to a shareable format. Go ahead, click it and move it around! About the Authors \u00b6 The PVGeo code library is managed by Bane Sullivan , graduate student in the Hydrological Science and Engineering interdisciplinary program at the Colorado School of Mines under Whitney Trainor-Guitton. If you have questions please inquire with info@pvgeo.org or join the PVGeo community on Slack: Thank you to our contributors! It is important to note the project is open source and that many features in this repository were made possible by contributors volunteering their time. Please take a look at the Contributors Page to learn more about the developers of PVGeo . Tweets by OpenGeoVis","title":"Home"},{"location":"#pvgeo","text":"PVGeo is a Python package that contains VTK powered tools for data visualization in geophysics which are wrapped for direct use within the application ParaView by Kitware . These tools are tailored to data visualization in the geosciences with a heavy focus on structured data sets like 2D or 3D time-varying grids. On this website, we provide several examples and tutorials of how to use PVGeo in a python environment as well as how to use the ParaView plugins delivered along side the python package for common tasks in the visualization of geoscientific data. Feel free to join the PVGeo community on Slack to keep up with new features and for any help using the code library and follow us on Twitter to keep up: Follow @OpenGeoVis Suggestions? If you have an idea for a file reader, data filter, ParaView plugin, or would like to see how we would address a geoscientific visualization problem with ParaView, please post your thoughts on the issues page or become involved with the PVGeo community discussions on Slack . How to use PVGeo To download and use the PVGeo code library, follow the installation instructions on the Getting Started Page . If you are interested in development, all code is published on the GitHub repository PVGeo linked to this page. Click the \u2018PVGeo on GitHub\u2019 link on the right side of the menu bar at the top to find all of the code or you can follow this link . Also take a look at the Development Guide How to explore this documentation On a Desktop: There are six main sections to this website shown in the navigation tab at the top of the page. Use these tabs to explore the different aspects of the project! Use the sidebar to the right to explore the contents of the current page and use the sidebar to the left to find all the different pages for this active section/tab. Here is a list of the available sections: Overview: An introduction to the project with installation details on how to get started. Examples: A guide to all of the plugins we have implemented for use directly in ParaView. This section has all the information you will need to understand how to use our plugins and how we group them together into what we call suites . This section has high level explanations and examples while the docs website has the code documentation. Docs: This tab will forward you to the code docs website PV Macros: A guide on how to use all of the macros developed in the pvmacros module. Resources: A conglomerate of additional resources that are helpful when using ParaView and VTK for geoscientific applications. Development Guide: This is an all encompassing guid on how to start making your own plugins as well as how to contribute to the PVGeo repository. Web renderings not working? If the web renderings like the one below in the demo section of this page are not working, then please make sure to enable javascript in your web browser.","title":"PVGeo"},{"location":"#demo","text":"Check out the Demo Page to see video demos and interactive demos like the scene below. This is an example of three data sets visually integrated using our framework within ParaView then exported to a shareable format. Go ahead, click it and move it around!","title":"Demo"},{"location":"#about-the-authors","text":"The PVGeo code library is managed by Bane Sullivan , graduate student in the Hydrological Science and Engineering interdisciplinary program at the Colorado School of Mines under Whitney Trainor-Guitton. If you have questions please inquire with info@pvgeo.org or join the PVGeo community on Slack: Thank you to our contributors! It is important to note the project is open source and that many features in this repository were made possible by contributors volunteering their time. Please take a look at the Contributors Page to learn more about the developers of PVGeo . Tweets by OpenGeoVis","title":"About the Authors"},{"location":"cmaps/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Color Maps"},{"location":"dev-guide/build-your-own-plugins/","text":"More to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Build Your Own Plugins"},{"location":"dev-guide/contributing/","text":"Thanks for taking the time to contribute! We absolutely welcome contributions and we hope that this guide will facilitate an understanding of the PVGeo code repository. It is important to note that the PVGeo software package is maintained on a volunteer basis and thus we need to foster a community that can support user questions and develop new features to make this software a useful tool for geoscientists. This page is dedicated to outline where you should start with your question, concern, feature request, or desire to contribute. Questions \u00b6 For general questions about the project, its applications, or about the non-technical, please do not create an issue but join us on slack or send one of the developers an email. The current project maintainer is Bane Sullivan , feel free to inquire with Bane. For more technical questions, you are welcome to create an issue on the issues page with a question label which we will try to address. Through posting on the issues page, your question can be addressed by community members with the needed expertise and the information gained will remain available on the issues page for other users. Reporting Bugs \u00b6 If you stumble across any bugs, crashes, or concerning quirks while using code distributed here, please report it on the issues page with an appropriate label so we can promptly address it. When reporting an issue, please be overly descriptive so that we may reproduce it. Whenever possible, please provide tracebacks, screenshots, and sample files to help us address the issue. Feature Requests \u00b6 We encourage users to submit ideas for improvements to PVGeo code base! Please create an issue on the issues page with a Feature Request label to suggest an improvement. Please use a descriptive title and provide ample background information to help the community implement that functionality. For example, if you would like a reader for a specific file format, please provide a link to documentation of that file format and possibly provide some sample files with screenshots to work with. We will use the issue thread as a place to discuss and provide feedback. Contributing New Code \u00b6 If you have an idea for how to improve PVGeo , please first create an issue as a feature request which we can use as a discussion thread to work through how to implement the contribution. Once you are ready to start coding and develop for PVGeo , please take a look at the remainder of the pages in this Development Guide. Licensing \u00b6 All contributed code will be licensed under PVGeos\u2019 license . If you did not write the code yourself, it is your responsibility to ensure that the existing license is compatible and included in the contributed files or you can obtain permission from the original author to relicense the code.","title":"Contributing"},{"location":"dev-guide/contributing/#questions","text":"For general questions about the project, its applications, or about the non-technical, please do not create an issue but join us on slack or send one of the developers an email. The current project maintainer is Bane Sullivan , feel free to inquire with Bane. For more technical questions, you are welcome to create an issue on the issues page with a question label which we will try to address. Through posting on the issues page, your question can be addressed by community members with the needed expertise and the information gained will remain available on the issues page for other users.","title":"Questions"},{"location":"dev-guide/contributing/#reporting-bugs","text":"If you stumble across any bugs, crashes, or concerning quirks while using code distributed here, please report it on the issues page with an appropriate label so we can promptly address it. When reporting an issue, please be overly descriptive so that we may reproduce it. Whenever possible, please provide tracebacks, screenshots, and sample files to help us address the issue.","title":"Reporting Bugs"},{"location":"dev-guide/contributing/#feature-requests","text":"We encourage users to submit ideas for improvements to PVGeo code base! Please create an issue on the issues page with a Feature Request label to suggest an improvement. Please use a descriptive title and provide ample background information to help the community implement that functionality. For example, if you would like a reader for a specific file format, please provide a link to documentation of that file format and possibly provide some sample files with screenshots to work with. We will use the issue thread as a place to discuss and provide feedback.","title":"Feature Requests"},{"location":"dev-guide/contributing/#contributing-new-code","text":"If you have an idea for how to improve PVGeo , please first create an issue as a feature request which we can use as a discussion thread to work through how to implement the contribution. Once you are ready to start coding and develop for PVGeo , please take a look at the remainder of the pages in this Development Guide.","title":"Contributing New Code"},{"location":"dev-guide/contributing/#licensing","text":"All contributed code will be licensed under PVGeos\u2019 license . If you did not write the code yourself, it is your responsibility to ensure that the existing license is compatible and included in the contributed files or you can obtain permission from the original author to relicense the code.","title":"Licensing"},{"location":"dev-guide/repo-structure/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page The Plugin Framework \u00b6 In developing the PVGeo repository, we decided to follow a framework of development that generates various sets of tools that can be used within ParaView or outside in other Python environments with the VTK Python library. This would allow for users of PVGeo to be able to use all of the functionality as plugins in ParaView with interactive user menus or outside of ParaView be able to integrate with there existing data processing suites using Python and VTK. This development framework also focuses heavily on the open source paradigm in that PVGeo contains many base classes for developers to inherit functionality to aid in the development of new features. Unfortunately, the development of plugins for the ParaView software platform may imply an ambitious programming endeavor, including creating CMakeLists, developing in lower level programming languages like C++, learning new libraries to create interactive GUI components, and building the plugins into the ParaView source code. However, the PVGeo module takes advantage of functionality by Kitware that facilitates the rapid development of readers, sources, filters, and writers: instantiations of the VTKPythonAlgorithmBase class in Python. Python is an accessible language, easy to learn, and popular among geoscientists using packages like: SimPEG, ObsPy, EarthPy, pyFLOWGO, GeoNotebook, and more. We choose to develop the PVGeo library to work well with other Python libraries by following the following framework: Extendable: This software will harness the established and robust visualization platforms ParaView and VTK, extend their functionality, and remain open-source for contributions and integration into other Python powered geoscientific processing suites. Safe: The software must preserve data integrity and precision. Dynamic: The software must enable a dynamic link between external processing software and visualization libraries. Modular: The software will be modular so that various visualization suites can be implemented separately but also work together. This software should be usable both within and outside of ParaView. Rapid development: Through further subclasses of the VTKPythonAlgorithmBase class and the templates in PVGeo , it is easy to prototype and develop a plugin in a matter of minutes without the need to rebuild the software. Computational power: VTK has NumPy wrapping to allow for the use of Python\u2019s complex numerical analysis libraries like SciPy and NumPy. Easy customization by end user: since most geoscientists know and use Python, they can easily dive into the source code delivered in this repo to tailor it to their needs. Easy GUI component creation: Graphical User Interface elements can be easily produced to pair with plugins. Outline of Goals \u00b6 Develop and document geoscientific plugins for ParaView encompassed in various suites. Each suite of plugins will be tailored to specific data formats and/or processing needs in geoscience. These plugins will take advantage of ParaView and VTK\u2019s Python wrapping and use the Python Programmable Filter in ParaView. The advantage to using Python Programmable filters is that they are easily modified by the end user and can be wrapped in XML to create a GUI for its use in ParaView while having the option to directly edit the source code live in ParaView. The suites of plugins will consist of the following plugin types: Readers: A reader puts data from files into proper ParaView data structures on the pipeline. These are plugins that read common geoscientific and geophysical spatial data files (GSLIB, UBC Tensor and OcTree meshes, etc.). Also make readers that read common raw data files (packed binary floats, delimited ASCII, etc.) Filters: A filter modifies, transforms, combines, analyses, etc. data on the ParaView pipeline. Plugins that perform post-processing analysis of geoscientific data for visualization. For example, filters that build tubes from a series of points that represent a tunnel or filters that take a 1D array, reshape it to 2D or 3D, and make a volumetric model ready for visualization all while adding spatial reference for visual integration. Sources: Plugins that create simple synthetic data sources that could be used for model generation. We are creating a suite of plugins for generating various types of discretized models/meshes which can be exported. Another example could include a sphere or cube with a specified attribute like a spatially varying density or electrical conductivity. Other sources might include using that synthetic sphere or cube to make a volumetric field of some response. These plugins will tailor to the educational needs in applications of this code base. Develop and document the PVGeo and pvmacros Python modules for use in ParaView\u2019s Python Shell. These modules will contain all of the macros, batch processing tasks, and common codes to apply to 3D data scenes. The PVGeo module will hold all of the code used in the plugins so that shared features across plugins can be called rather the rewritten and so that we can version control the plugins. This module will be primarily for use in the plugins scripts and not necessary for use in the ParaViewPython shell. The pvmacros module with be full of macros and other data-independent scripts that can be used directly in the ParaViewPython shell. Make tutorials on the use of the tools provided by this repository as well as share how to use ParaView\u2019s native features on open source data (for example): Develop customizable scripts for the visualization of common data formats. This will include developing scripts on an individual basis to help others quickly visualize their data and models for quality assessment and unique research needs.","title":"Repo Structure"},{"location":"dev-guide/repo-structure/#the-plugin-framework","text":"In developing the PVGeo repository, we decided to follow a framework of development that generates various sets of tools that can be used within ParaView or outside in other Python environments with the VTK Python library. This would allow for users of PVGeo to be able to use all of the functionality as plugins in ParaView with interactive user menus or outside of ParaView be able to integrate with there existing data processing suites using Python and VTK. This development framework also focuses heavily on the open source paradigm in that PVGeo contains many base classes for developers to inherit functionality to aid in the development of new features. Unfortunately, the development of plugins for the ParaView software platform may imply an ambitious programming endeavor, including creating CMakeLists, developing in lower level programming languages like C++, learning new libraries to create interactive GUI components, and building the plugins into the ParaView source code. However, the PVGeo module takes advantage of functionality by Kitware that facilitates the rapid development of readers, sources, filters, and writers: instantiations of the VTKPythonAlgorithmBase class in Python. Python is an accessible language, easy to learn, and popular among geoscientists using packages like: SimPEG, ObsPy, EarthPy, pyFLOWGO, GeoNotebook, and more. We choose to develop the PVGeo library to work well with other Python libraries by following the following framework: Extendable: This software will harness the established and robust visualization platforms ParaView and VTK, extend their functionality, and remain open-source for contributions and integration into other Python powered geoscientific processing suites. Safe: The software must preserve data integrity and precision. Dynamic: The software must enable a dynamic link between external processing software and visualization libraries. Modular: The software will be modular so that various visualization suites can be implemented separately but also work together. This software should be usable both within and outside of ParaView. Rapid development: Through further subclasses of the VTKPythonAlgorithmBase class and the templates in PVGeo , it is easy to prototype and develop a plugin in a matter of minutes without the need to rebuild the software. Computational power: VTK has NumPy wrapping to allow for the use of Python\u2019s complex numerical analysis libraries like SciPy and NumPy. Easy customization by end user: since most geoscientists know and use Python, they can easily dive into the source code delivered in this repo to tailor it to their needs. Easy GUI component creation: Graphical User Interface elements can be easily produced to pair with plugins.","title":"The Plugin Framework"},{"location":"dev-guide/repo-structure/#outline-of-goals","text":"Develop and document geoscientific plugins for ParaView encompassed in various suites. Each suite of plugins will be tailored to specific data formats and/or processing needs in geoscience. These plugins will take advantage of ParaView and VTK\u2019s Python wrapping and use the Python Programmable Filter in ParaView. The advantage to using Python Programmable filters is that they are easily modified by the end user and can be wrapped in XML to create a GUI for its use in ParaView while having the option to directly edit the source code live in ParaView. The suites of plugins will consist of the following plugin types: Readers: A reader puts data from files into proper ParaView data structures on the pipeline. These are plugins that read common geoscientific and geophysical spatial data files (GSLIB, UBC Tensor and OcTree meshes, etc.). Also make readers that read common raw data files (packed binary floats, delimited ASCII, etc.) Filters: A filter modifies, transforms, combines, analyses, etc. data on the ParaView pipeline. Plugins that perform post-processing analysis of geoscientific data for visualization. For example, filters that build tubes from a series of points that represent a tunnel or filters that take a 1D array, reshape it to 2D or 3D, and make a volumetric model ready for visualization all while adding spatial reference for visual integration. Sources: Plugins that create simple synthetic data sources that could be used for model generation. We are creating a suite of plugins for generating various types of discretized models/meshes which can be exported. Another example could include a sphere or cube with a specified attribute like a spatially varying density or electrical conductivity. Other sources might include using that synthetic sphere or cube to make a volumetric field of some response. These plugins will tailor to the educational needs in applications of this code base. Develop and document the PVGeo and pvmacros Python modules for use in ParaView\u2019s Python Shell. These modules will contain all of the macros, batch processing tasks, and common codes to apply to 3D data scenes. The PVGeo module will hold all of the code used in the plugins so that shared features across plugins can be called rather the rewritten and so that we can version control the plugins. This module will be primarily for use in the plugins scripts and not necessary for use in the ParaViewPython shell. The pvmacros module with be full of macros and other data-independent scripts that can be used directly in the ParaViewPython shell. Make tutorials on the use of the tools provided by this repository as well as share how to use ParaView\u2019s native features on open source data (for example): Develop customizable scripts for the visualization of common data formats. This will include developing scripts on an individual basis to help others quickly visualize their data and models for quality assessment and unique research needs.","title":"Outline of Goals"},{"location":"dev-guide/style/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Style Guide"},{"location":"dev-guide/templates/","text":"Here are a few templates for various types of algorithms to provide a place to start developing your own readers, filters, writers, and sources! Once you have your new algorithm implemented, head over to this example to learn more about wrapping your algorithm for direct use in ParaView. Through decorating a new subclass of your algorithm, you can define a user interface that ParaView can easily yield to users! Readers \u00b6 We\u2019ve found that it is difficult to make generic templates for readers as there are already so many reader base classes to choose from. If you are developing a new reader, talk to one of the active developers on Slack and we can work with you to ensure you are using an appropriate base class. Filters \u00b6 A filter that will preserve the input data type: # Import Helpers: TODO Check relativity from ..base import FilterPreserveTypeBase from .. import _helpers class FilterTemplate ( FilterPreserveTypeBase ): \"\"\"A filter that preserves the input type template for you! Inheriting from ``FilterPreserveTypeBase`` allows your new filter to handle all the complicated processes necessary for making sure the pipeline properly sets up the output data object. All you have to so is appropriately fill out the ``RequestData`` method! \"\"\" __displayname__ = 'Filter Template' __category__ = 'filter' def __init__ ( self , ** kwargs ): FilterPreserveTypeBase . __init__ ( self , ** kwargs ) self . __property = kwargs . get ( 'prop' , None ) def RequestData ( self , request , inInfo , outInfo ): \"\"\"This is where you fill out your algorithm\"\"\" pdi = self . GetInputData ( inInfo , 0 , 0 ) # int args are port and index pdo = self . GetOutputData ( outInfo , 0 ) # int arg is port # TODO: Perform your data processing here raise NotImplementedError ( 'Code me up!' ) return 1 # ALWAYS return 1 def SetProperty ( self , prop ): \"\"\"A generic setter method for a private property\"\"\" if self . __property != prop : self . __property = prop self . Modified () A filter that will alter the data type: # Import Helpers: TODO Check relativity from ..base import FilterBase from .. import _helpers class FilterTemplate ( FilterBase ): \"\"\"A generic filter template for you! Inheriting from ``FilterBase`` allows your new filter to be properly set up on the pipeline with ease. Be sure to properly set the input/output data object types and number of ports via the ``FilterBase`` super constructor. \"\"\" __displayname__ = 'Filter Template' __category__ = 'filter' def __init__ ( self , ** kwargs ): FilterBase . __init__ ( self , nInputPorts = 1 , inputType = 'vtkDataSet' , nOutputPorts = 1 , outputType = 'vtkPolyData' , ** kwargs ) self . __property = kwargs . get ( 'prop' , None ) def RequestData ( self , request , inInfo , outInfo ): \"\"\"This is where you fill out your algorithm\"\"\" pdi = self . GetInputData ( inInfo , 0 , 0 ) # int args are port and index pdo = self . GetOutputData ( outInfo , 0 ) # int arg is port # TODO: Perform your data processing here raise NotImplementedError ( 'Code me up!' ) return 1 # ALWAYS return 1 def SetProperty ( self , prop ): \"\"\"A generic setter method for a private property\"\"\" if self . __property != prop : self . __property = prop self . Modified () Need to include a data array selection in your filter? It\u2019s easy: from vtk.numpy_interface import dataset_adapter as dsa # Import Helpers: TODO Check relativity from ..base import FilterBase from .. import _helpers class FilterTemplate ( FilterBase ): \"\"\"A generic filter template with a data array selection for you! \"\"\" __displayname__ = 'Filter Template' __category__ = 'filter' def __init__ ( self , ** kwargs ): FilterBase . __init__ ( self , nInputPorts = 1 , inputType = 'vtkDataSet' , nOutputPorts = 1 , outputType = 'vtkPolyData' , ** kwargs ) self . __inputArray = [ None , None ] def RequestData ( self , request , inInfo , outInfo ): \"\"\"This is where you fill out your algorithm\"\"\" pdi = self . GetInputData ( inInfo , 0 , 0 ) # int args are port and index pdo = self . GetOutputData ( outInfo , 0 ) # int arg is port # Get Input Array field , name = self . __inputArray [ 0 ], self . __inputArray [ 1 ] wpdi = dsa . WrapDataObject ( pdi ) arr = _helpers . getNumPyArray ( wpdi , field , name ) # TODO: Perform your data processing here raise NotImplementedError ( 'Code me up!' ) return 1 # ALWAYS return 1 def SetInputArrayToProcess ( self , idx , port , connection , field , name ): \"\"\"Used to set the input array(s) Args: idx (int): the index of the array to process port (int): input port (use 0 if unsure) connection (int): the connection on the port (use 0 if unsure) field (int): the array field (0 for points, 1 for cells, 2 for field, and 6 for row) name (int): the name of the array \"\"\" if self . __inputArray [ 0 ] != field or self . __inputArray [ 1 ] != name : self . __inputArray [ 0 ] = field self . __inputArray [ 1 ] = name self . __filter . SetInputArrayToProcess ( idx , port , connection , field , name ) self . Modified () return 1 Writers \u00b6 # Import Helpers: TODO Check relativity from ..base import WriterBase from .. import _helpers class WriteTemplate ( WriterBase ): \"\"\"A writer template for you! Write the overall description of this writer here. E.g. This writers takes ``XXX`` as and saves it to a file of the ``YYY`` format for use in software such as ZZZ. \"\"\" __displayname__ = 'Write Template' __category__ = 'writer' def __init__ ( self , ** kwargs ): WriterBase . __init__ ( self , inputType = 'vtkDataSet' , ** kwargs ) # Set private variables here! self . __foo = kwargs . get ( 'foo' , True ) def PerformWriteOut ( self , inputDataObject , filename ): \"\"\"Use ``inputDataObject`` and ``filename`` to save the VTK data object to your custom file type. Args: inputDataObject (vtkDataObject): This is guaranteed to be of the type specified by the ``inputType`` in your ``__init__`` unless you override ``FillInputPortInformation``. filename (str): A full filename with an index appended if needed. Use this string to save your data. Return: int: return 1 on success \"\"\" raise NotImplementedError ( 'Code me up!' ) # Always return 1 return 1 def SetFoo ( self , foo ): \"\"\"Set the foo variable\"\"\" if self . __foo != foo : self . __foo = foo self . Modified () Sources \u00b6 # Import Helpers: TODO: Check relativity from ..base import AlgorithmBase from .. import _helpers class TemplateSource ( AlgorithmBase ): \"\"\"A source template for you! Write the overall description of this source here. E.g. This source produces a ``XXX`` object that describes some useful information. \"\"\" __displayname__ = 'Template Source' __category__ = 'source' def __init__ ( self , ** kwargs ): AlgorithmBase . __init__ ( self , nInputPorts = 0 , nOutputPorts = 1 , outputType = 'vtkPolyData' ) # Set private variables here! self . __foo = kwargs . get ( 'foo' , True ) def RequestData ( self , request , inInfo , outInfo ): \"\"\"This is where you fill out your algorithm\"\"\" pdo = self . GetOutputData ( outInfo , 0 ) # TODO: Fill in the output data object: ``pdo`` raise NotImplementedError ( 'Code me up!' ) return 1 def SetFoo ( self , foo ): \"\"\"Set the foo variable\"\"\" if self . __foo != foo : self . __foo = foo self . Modified ()","title":"Templates"},{"location":"dev-guide/templates/#readers","text":"We\u2019ve found that it is difficult to make generic templates for readers as there are already so many reader base classes to choose from. If you are developing a new reader, talk to one of the active developers on Slack and we can work with you to ensure you are using an appropriate base class.","title":"Readers"},{"location":"dev-guide/templates/#filters","text":"A filter that will preserve the input data type: # Import Helpers: TODO Check relativity from ..base import FilterPreserveTypeBase from .. import _helpers class FilterTemplate ( FilterPreserveTypeBase ): \"\"\"A filter that preserves the input type template for you! Inheriting from ``FilterPreserveTypeBase`` allows your new filter to handle all the complicated processes necessary for making sure the pipeline properly sets up the output data object. All you have to so is appropriately fill out the ``RequestData`` method! \"\"\" __displayname__ = 'Filter Template' __category__ = 'filter' def __init__ ( self , ** kwargs ): FilterPreserveTypeBase . __init__ ( self , ** kwargs ) self . __property = kwargs . get ( 'prop' , None ) def RequestData ( self , request , inInfo , outInfo ): \"\"\"This is where you fill out your algorithm\"\"\" pdi = self . GetInputData ( inInfo , 0 , 0 ) # int args are port and index pdo = self . GetOutputData ( outInfo , 0 ) # int arg is port # TODO: Perform your data processing here raise NotImplementedError ( 'Code me up!' ) return 1 # ALWAYS return 1 def SetProperty ( self , prop ): \"\"\"A generic setter method for a private property\"\"\" if self . __property != prop : self . __property = prop self . Modified () A filter that will alter the data type: # Import Helpers: TODO Check relativity from ..base import FilterBase from .. import _helpers class FilterTemplate ( FilterBase ): \"\"\"A generic filter template for you! Inheriting from ``FilterBase`` allows your new filter to be properly set up on the pipeline with ease. Be sure to properly set the input/output data object types and number of ports via the ``FilterBase`` super constructor. \"\"\" __displayname__ = 'Filter Template' __category__ = 'filter' def __init__ ( self , ** kwargs ): FilterBase . __init__ ( self , nInputPorts = 1 , inputType = 'vtkDataSet' , nOutputPorts = 1 , outputType = 'vtkPolyData' , ** kwargs ) self . __property = kwargs . get ( 'prop' , None ) def RequestData ( self , request , inInfo , outInfo ): \"\"\"This is where you fill out your algorithm\"\"\" pdi = self . GetInputData ( inInfo , 0 , 0 ) # int args are port and index pdo = self . GetOutputData ( outInfo , 0 ) # int arg is port # TODO: Perform your data processing here raise NotImplementedError ( 'Code me up!' ) return 1 # ALWAYS return 1 def SetProperty ( self , prop ): \"\"\"A generic setter method for a private property\"\"\" if self . __property != prop : self . __property = prop self . Modified () Need to include a data array selection in your filter? It\u2019s easy: from vtk.numpy_interface import dataset_adapter as dsa # Import Helpers: TODO Check relativity from ..base import FilterBase from .. import _helpers class FilterTemplate ( FilterBase ): \"\"\"A generic filter template with a data array selection for you! \"\"\" __displayname__ = 'Filter Template' __category__ = 'filter' def __init__ ( self , ** kwargs ): FilterBase . __init__ ( self , nInputPorts = 1 , inputType = 'vtkDataSet' , nOutputPorts = 1 , outputType = 'vtkPolyData' , ** kwargs ) self . __inputArray = [ None , None ] def RequestData ( self , request , inInfo , outInfo ): \"\"\"This is where you fill out your algorithm\"\"\" pdi = self . GetInputData ( inInfo , 0 , 0 ) # int args are port and index pdo = self . GetOutputData ( outInfo , 0 ) # int arg is port # Get Input Array field , name = self . __inputArray [ 0 ], self . __inputArray [ 1 ] wpdi = dsa . WrapDataObject ( pdi ) arr = _helpers . getNumPyArray ( wpdi , field , name ) # TODO: Perform your data processing here raise NotImplementedError ( 'Code me up!' ) return 1 # ALWAYS return 1 def SetInputArrayToProcess ( self , idx , port , connection , field , name ): \"\"\"Used to set the input array(s) Args: idx (int): the index of the array to process port (int): input port (use 0 if unsure) connection (int): the connection on the port (use 0 if unsure) field (int): the array field (0 for points, 1 for cells, 2 for field, and 6 for row) name (int): the name of the array \"\"\" if self . __inputArray [ 0 ] != field or self . __inputArray [ 1 ] != name : self . __inputArray [ 0 ] = field self . __inputArray [ 1 ] = name self . __filter . SetInputArrayToProcess ( idx , port , connection , field , name ) self . Modified () return 1","title":"Filters"},{"location":"dev-guide/templates/#writers","text":"# Import Helpers: TODO Check relativity from ..base import WriterBase from .. import _helpers class WriteTemplate ( WriterBase ): \"\"\"A writer template for you! Write the overall description of this writer here. E.g. This writers takes ``XXX`` as and saves it to a file of the ``YYY`` format for use in software such as ZZZ. \"\"\" __displayname__ = 'Write Template' __category__ = 'writer' def __init__ ( self , ** kwargs ): WriterBase . __init__ ( self , inputType = 'vtkDataSet' , ** kwargs ) # Set private variables here! self . __foo = kwargs . get ( 'foo' , True ) def PerformWriteOut ( self , inputDataObject , filename ): \"\"\"Use ``inputDataObject`` and ``filename`` to save the VTK data object to your custom file type. Args: inputDataObject (vtkDataObject): This is guaranteed to be of the type specified by the ``inputType`` in your ``__init__`` unless you override ``FillInputPortInformation``. filename (str): A full filename with an index appended if needed. Use this string to save your data. Return: int: return 1 on success \"\"\" raise NotImplementedError ( 'Code me up!' ) # Always return 1 return 1 def SetFoo ( self , foo ): \"\"\"Set the foo variable\"\"\" if self . __foo != foo : self . __foo = foo self . Modified ()","title":"Writers"},{"location":"dev-guide/templates/#sources","text":"# Import Helpers: TODO: Check relativity from ..base import AlgorithmBase from .. import _helpers class TemplateSource ( AlgorithmBase ): \"\"\"A source template for you! Write the overall description of this source here. E.g. This source produces a ``XXX`` object that describes some useful information. \"\"\" __displayname__ = 'Template Source' __category__ = 'source' def __init__ ( self , ** kwargs ): AlgorithmBase . __init__ ( self , nInputPorts = 0 , nOutputPorts = 1 , outputType = 'vtkPolyData' ) # Set private variables here! self . __foo = kwargs . get ( 'foo' , True ) def RequestData ( self , request , inInfo , outInfo ): \"\"\"This is where you fill out your algorithm\"\"\" pdo = self . GetOutputData ( outInfo , 0 ) # TODO: Fill in the output data object: ``pdo`` raise NotImplementedError ( 'Code me up!' ) return 1 def SetFoo ( self , foo ): \"\"\"Set the foo variable\"\"\" if self . __foo != foo : self . __foo = foo self . Modified ()","title":"Sources"},{"location":"dev-guide/snippets/composite-data-writers/","text":"Composite Data Writers \u00b6 Author This snippet was written by Bane Sullivan and was originally posted on ParaView\u2019s GitLab project snippets here . See the source section for the resulting output. The functionality using decorated VTKPythonAlgorithmBase classes as ParaView plugins has a composite support option for the smdomain input property that is incredibly simple to use with filter algorithms yet can be tricky to use for writer algorithms. @smproxy.writer ( ... ) @smproperty.input ( name = \"TableInput\" , port_index = 0 ) @smdomain.datatype ( dataTypes = [ \"vtkTable\" ], composite_data_supported = True ) class MyWriter ( VTKPythonAlgorithmBase ): ... The provided snippet in the source section of this page provides a simple base class for a user to inherit functionality which is a modification of PVGeo\u2019s WriterBase algorithm ( Take a look at WriterBase \u2018s code docs here ). In this example I demonstrate the use of this base class through creating a writer algorithm that will save out XYZ+attribute data of the cell centers and cell data for any given input datasets. This solution handles altering the given filename to save out each object in the composite dataset separately by saving each block out in PerformWriteOut method that is repeatedly called by RequestData explicitly. Note Note that we must use the composite_data_supported = True flag for the @smproxy . writer (...) declaration as well as append allowable input types within the algorithms FillInputPortInformation method. # This is partially pseudo-code and is implemented in `WriterBase` @smproxy.writer ( ... ) @smproperty.input ( name = \"Input\" , port_index = 0 ) @smdomain.datatype ( dataTypes = [ \"vtkDataSet\" ], composite_data_supported = True ) class MyWriter ( VTKPythonAlgorithmBase ): ... def FillInputPortInformation ( self , port , info ): \"\"\"Allows us to save composite datasets as well. NOTE: I only care about ``vtkMultiBlockDataSet``s \"\"\" info . Set ( self . INPUT_REQUIRED_DATA_TYPE (), self . InputType ) info . Append ( self . INPUT_REQUIRED_DATA_TYPE (), 'vtkMultiBlockDataSet' ) return 1 def PerformWriteOut ( self , inputDataObject , filename ): \"\"\"This method must be implemented. This is automatically called by ``RequestData`` for single inputs or composite inputs.\"\"\" raise NotImplementedError ( 'PerformWriteOut must be implemented!' ) def RequestData ( self , request , inInfoVec , outInfoVec ): \"\"\"Subclasses must implement a ``PerformWriteOut`` method that takes an input data object and a filename. This method will automatically handle composite data sets. \"\"\" inp = self . GetInputData ( inInfoVec , 0 , 0 ) # Handle composite datasets. # NOTE: This only handles 'vtkMultiBlockDataSet' if isinstance ( inp , vtk . vtkMultiBlockDataSet ): num = inp . GetNumberOfBlocks () # Create a list of filenames that vary by block index self . SetBlockFileNames ( num ) for i in range ( num ): data = inp . GetBlock ( i ) if data . IsTypeOf ( self . InputType ): self . PerformWriteOut ( data , self . GetBlockFileName ( i )) else : print ( 'Invalid input block %d of type( %s )' % ( i , type ( data ))) # Handle single input dataset else : self . PerformWriteOut ( inp , self . GetFileName ()) return 1","title":"Composite Writer"},{"location":"dev-guide/snippets/composite-data-writers/#composite-data-writers","text":"Author This snippet was written by Bane Sullivan and was originally posted on ParaView\u2019s GitLab project snippets here . See the source section for the resulting output. The functionality using decorated VTKPythonAlgorithmBase classes as ParaView plugins has a composite support option for the smdomain input property that is incredibly simple to use with filter algorithms yet can be tricky to use for writer algorithms. @smproxy.writer ( ... ) @smproperty.input ( name = \"TableInput\" , port_index = 0 ) @smdomain.datatype ( dataTypes = [ \"vtkTable\" ], composite_data_supported = True ) class MyWriter ( VTKPythonAlgorithmBase ): ... The provided snippet in the source section of this page provides a simple base class for a user to inherit functionality which is a modification of PVGeo\u2019s WriterBase algorithm ( Take a look at WriterBase \u2018s code docs here ). In this example I demonstrate the use of this base class through creating a writer algorithm that will save out XYZ+attribute data of the cell centers and cell data for any given input datasets. This solution handles altering the given filename to save out each object in the composite dataset separately by saving each block out in PerformWriteOut method that is repeatedly called by RequestData explicitly. Note Note that we must use the composite_data_supported = True flag for the @smproxy . writer (...) declaration as well as append allowable input types within the algorithms FillInputPortInformation method. # This is partially pseudo-code and is implemented in `WriterBase` @smproxy.writer ( ... ) @smproperty.input ( name = \"Input\" , port_index = 0 ) @smdomain.datatype ( dataTypes = [ \"vtkDataSet\" ], composite_data_supported = True ) class MyWriter ( VTKPythonAlgorithmBase ): ... def FillInputPortInformation ( self , port , info ): \"\"\"Allows us to save composite datasets as well. NOTE: I only care about ``vtkMultiBlockDataSet``s \"\"\" info . Set ( self . INPUT_REQUIRED_DATA_TYPE (), self . InputType ) info . Append ( self . INPUT_REQUIRED_DATA_TYPE (), 'vtkMultiBlockDataSet' ) return 1 def PerformWriteOut ( self , inputDataObject , filename ): \"\"\"This method must be implemented. This is automatically called by ``RequestData`` for single inputs or composite inputs.\"\"\" raise NotImplementedError ( 'PerformWriteOut must be implemented!' ) def RequestData ( self , request , inInfoVec , outInfoVec ): \"\"\"Subclasses must implement a ``PerformWriteOut`` method that takes an input data object and a filename. This method will automatically handle composite data sets. \"\"\" inp = self . GetInputData ( inInfoVec , 0 , 0 ) # Handle composite datasets. # NOTE: This only handles 'vtkMultiBlockDataSet' if isinstance ( inp , vtk . vtkMultiBlockDataSet ): num = inp . GetNumberOfBlocks () # Create a list of filenames that vary by block index self . SetBlockFileNames ( num ) for i in range ( num ): data = inp . GetBlock ( i ) if data . IsTypeOf ( self . InputType ): self . PerformWriteOut ( data , self . GetBlockFileName ( i )) else : print ( 'Invalid input block %d of type( %s )' % ( i , type ( data ))) # Handle single input dataset else : self . PerformWriteOut ( inp , self . GetFileName ()) return 1","title":"Composite Data Writers"},{"location":"examples/about-examples/","text":"About Examples \u00b6 PVGeo is deployed in various sub-packages called suites . These suites consist of a set of reader, filter, source, or writer algorithms (or any combination of those) for a general area of geoscientific processing and visualization. The following sections on this page demonstrate general procedures and syntax to use each type of algorithm within ParaView or directly in a Python environment. Take a look at the Contents Page for an outline and synopsis of each example or look at the navigation pane to the left to explore the different suites in their drop down menu. Each feature (reader, filter, etc.) has its own page where you can find an overview of that feature, an example of how to use it directly in ParaView, and an example on how to use it in a standard Python environment. For example specific questions, concerns, or insights, please leave a comment at the bottom of that example\u2019s page for other users to find. If you think there may be a serious problem with an example, please open an issue on the issues page so that we can promptly fix it. Typical Usage \u00b6 All algorithms deployed in PVGeo are useable in the following manners in a Python environment where the algorithm can be called and instantiated with keyword arguments for its parameters and then applied on some input data set. import PVGeo # PSEUDOCODE: Typical use of a PVGeo algorithm: output = PVGeo . suite . Algorithm ( ** kwargs ) . Apply ( input ) Or we can instantiate the algorithm for repetitive calls if, for example, we need to request varying time steps. import PVGeo # PSEUDOCODE: Typical use of a PVGeo algorithm: alg = PVGeo . suite . Algorithm ( ** kwargs ) # Grab the output data object output = alg . Apply ( input ) # Update the output to a desired time step alg . UpdateTimeStep ( 6.0 ) Reader Algorithms \u00b6 A reader takes data from files and puts them into the proper VTK and ParaView data structures so that we can visualize that data on the VTK or ParaView pipeline. ParaView comes with a plethora of native data format readers but there are still many more formats in the geosciences that have not been implemented. By creating formats for common geoscientific formats, we hope to make the process of getting data into the ParaView pipeline as simple as possible. ParaView Usage \u00b6 The PVGeo readers aren\u2019t directly available in the GUI menus of ParaView but rather a dialog will appear for you to select the desired file reader when selecting File -> Open\u2026 within ParaView like the screen recording below: Python Usage \u00b6 The file readers in PVGeo are available for use in the same manner as all algorithms in PVGeo . Readers are typically used in a manner that allows the reader algorithm to be repetitively called to request various time steps: import PVGeo # PSEUDOCODE: Typical use of a PVGeo reader: reader = PVGeo . suite . Reader ( ** kwargs ) reader . AddFileName ([ 'file %.2d ' % i for i in range ( 20 )]) # Grab the output data object output = reader . Apply () # NOTE: Readers have no input for the `Apply()` call # Update the output to a desired time step reader . UpdateTimeStep ( 6.0 ) It is worth noting that if you have only one file (one time step) to read, then readers can be used to immediately produce a data object: import PVGeo # PSEUDOCODE: Typical use of a PVGeo reader: output = PVGeo . suite . Reader ( fileName = 'fname.txt' , ** kwargs ) . Apply () Filter Algorithms \u00b6 A filter modifies, transforms, combines, analyses, processes, etc. data in VTK data structures on either a VTK or ParaView pipeline. Filters provide a means for changing how we visualize data or create a means of generating topology for an input data source to better represent that data in a 3D rendering environment. For example, we have developed a filter called Voxelize Points which takes a set of scattered points sampled on a rectilinear reference frame and generates voxels for every point such that the volume of data made by the points is filled with topologically connected cells. Or for another filter, maybe we might have a series of scattered points that we know represent the center of a tunnel or tube that represents a well. We can use a filter to transform those points into a connected line that we then construct a cylinder around. This allows us to save out minimal data (just XYZ points as opposed to complex geometries that make up the tunnel) to our hard drive while still having complex visualizations from that data. ParaView Usage \u00b6 Within ParaView, filters are available for selection directly from the GUI menus when an input data source is selected on the pipeline. All of the PVGeo filters are available under their own categories in the Filters menu. Python Usage \u00b6 Filters are typically used in a manner that parameters are set and an input dataset is provided to immediately produce an output. The parameters/options of the filter are set via the ** kwargs upon construction and the input(s) is/are given to the Apply () call: import PVGeo # PSEUDOCODE: Typical use of a PVGeo filter: output = PVGeo . suite . Filter ( ** kwargs ) . Apply ( inputDataObject ) import PVGeo # PSEUDOCODE: Typical use of a PVGeo filter with multiple inputs: output = PVGeo . suite . Filter ( ** kwargs ) . Apply ( input0 , input1 ) It is also worth noting that filter algorithms can be used as their own entities to make repetitive calls on them much like we showed with readers: import PVGeo # PSEUDOCODE: Typical use of a PVGeo filter: filt = PVGeo . suite . Filter ( ** kwargs ) output = filt . Apply ( inputDataObject ) # Change a parameter of the filter filt . SetParameter ( True ) # PSEUDOCODE filt . Update () # Make sure to update the output after changing a parameter # Request a different time step filt . UpdateTimeStep ( 6.0 ) Source Algorithms \u00b6 A source takes input parameters from a user and generates a data object for visualization or export. In PVGeo , we have implemented the Model Building suite with many sources that allow for a user to specify attributes of a data set such as a model discretization and have a data source appear in the rendering environment alongside their other data for that scene. ParaView Usage \u00b6 Within ParaView, sources are available for selection directly from the GUI menus. All of the PVGeo sources are available under their own categories in the Sources menu. Python Usage \u00b6 Sources can be used like any algorithm in PVGeo and are typically called to immediately produce an output like below: import PVGeo # PSEUDOCODE: Typical use of a PVGeo source: output = PVGeo . suite . Source ( ** kwargs ) . Apply () Writer Algorithms \u00b6 PVGeo writers take VTK data structures and write them out to the disk in a non-VTK formats that might be a standard for geoscientific data. PVGeo readers are often deployed with their complimentary writer equivalents such that data can be imported to the pipeline using readers, transformed using filters, then output to the same format in memory for use in an external processing library. ParaView Usage \u00b6 Demonstrated in the following video, a user can select File -> Save Data in ParaView with a selected dataset then choose one of PVGeo \u2018s writers. The first 1 minute in the video demonstrates the Extract Topography then the video shows how to save a vtkRectilinearGrid and its attributes to the UBC Tensor Mesh/Model formats using a PVGeo writer. Python Usage \u00b6 Writers can be used like any algorithm in PVGeo and are typically called to immediately write out a data object like below. import PVGeo # PSEUDOCODE: Typical use of a PVGeo writer: writer = PVGeo . suite . Writer ( ** kwargs ) filename = 'test-writer.grd' writer . SetFileName ( filename ) writer . Write ( inputDataObject ) Writers: No Time Support Currently At the moment, the writers do not properly sink data on a time varying pipeline. This is a bug we are working to fix!","title":"About Examples"},{"location":"examples/about-examples/#about-examples","text":"PVGeo is deployed in various sub-packages called suites . These suites consist of a set of reader, filter, source, or writer algorithms (or any combination of those) for a general area of geoscientific processing and visualization. The following sections on this page demonstrate general procedures and syntax to use each type of algorithm within ParaView or directly in a Python environment. Take a look at the Contents Page for an outline and synopsis of each example or look at the navigation pane to the left to explore the different suites in their drop down menu. Each feature (reader, filter, etc.) has its own page where you can find an overview of that feature, an example of how to use it directly in ParaView, and an example on how to use it in a standard Python environment. For example specific questions, concerns, or insights, please leave a comment at the bottom of that example\u2019s page for other users to find. If you think there may be a serious problem with an example, please open an issue on the issues page so that we can promptly fix it.","title":"About Examples"},{"location":"examples/about-examples/#typical-usage","text":"All algorithms deployed in PVGeo are useable in the following manners in a Python environment where the algorithm can be called and instantiated with keyword arguments for its parameters and then applied on some input data set. import PVGeo # PSEUDOCODE: Typical use of a PVGeo algorithm: output = PVGeo . suite . Algorithm ( ** kwargs ) . Apply ( input ) Or we can instantiate the algorithm for repetitive calls if, for example, we need to request varying time steps. import PVGeo # PSEUDOCODE: Typical use of a PVGeo algorithm: alg = PVGeo . suite . Algorithm ( ** kwargs ) # Grab the output data object output = alg . Apply ( input ) # Update the output to a desired time step alg . UpdateTimeStep ( 6.0 )","title":"Typical Usage"},{"location":"examples/about-examples/#reader-algorithms","text":"A reader takes data from files and puts them into the proper VTK and ParaView data structures so that we can visualize that data on the VTK or ParaView pipeline. ParaView comes with a plethora of native data format readers but there are still many more formats in the geosciences that have not been implemented. By creating formats for common geoscientific formats, we hope to make the process of getting data into the ParaView pipeline as simple as possible.","title":"Reader Algorithms"},{"location":"examples/about-examples/#paraview-usage","text":"The PVGeo readers aren\u2019t directly available in the GUI menus of ParaView but rather a dialog will appear for you to select the desired file reader when selecting File -> Open\u2026 within ParaView like the screen recording below:","title":"ParaView Usage"},{"location":"examples/about-examples/#python-usage","text":"The file readers in PVGeo are available for use in the same manner as all algorithms in PVGeo . Readers are typically used in a manner that allows the reader algorithm to be repetitively called to request various time steps: import PVGeo # PSEUDOCODE: Typical use of a PVGeo reader: reader = PVGeo . suite . Reader ( ** kwargs ) reader . AddFileName ([ 'file %.2d ' % i for i in range ( 20 )]) # Grab the output data object output = reader . Apply () # NOTE: Readers have no input for the `Apply()` call # Update the output to a desired time step reader . UpdateTimeStep ( 6.0 ) It is worth noting that if you have only one file (one time step) to read, then readers can be used to immediately produce a data object: import PVGeo # PSEUDOCODE: Typical use of a PVGeo reader: output = PVGeo . suite . Reader ( fileName = 'fname.txt' , ** kwargs ) . Apply ()","title":"Python Usage"},{"location":"examples/about-examples/#filter-algorithms","text":"A filter modifies, transforms, combines, analyses, processes, etc. data in VTK data structures on either a VTK or ParaView pipeline. Filters provide a means for changing how we visualize data or create a means of generating topology for an input data source to better represent that data in a 3D rendering environment. For example, we have developed a filter called Voxelize Points which takes a set of scattered points sampled on a rectilinear reference frame and generates voxels for every point such that the volume of data made by the points is filled with topologically connected cells. Or for another filter, maybe we might have a series of scattered points that we know represent the center of a tunnel or tube that represents a well. We can use a filter to transform those points into a connected line that we then construct a cylinder around. This allows us to save out minimal data (just XYZ points as opposed to complex geometries that make up the tunnel) to our hard drive while still having complex visualizations from that data.","title":"Filter Algorithms"},{"location":"examples/about-examples/#paraview-usage_1","text":"Within ParaView, filters are available for selection directly from the GUI menus when an input data source is selected on the pipeline. All of the PVGeo filters are available under their own categories in the Filters menu.","title":"ParaView Usage"},{"location":"examples/about-examples/#python-usage_1","text":"Filters are typically used in a manner that parameters are set and an input dataset is provided to immediately produce an output. The parameters/options of the filter are set via the ** kwargs upon construction and the input(s) is/are given to the Apply () call: import PVGeo # PSEUDOCODE: Typical use of a PVGeo filter: output = PVGeo . suite . Filter ( ** kwargs ) . Apply ( inputDataObject ) import PVGeo # PSEUDOCODE: Typical use of a PVGeo filter with multiple inputs: output = PVGeo . suite . Filter ( ** kwargs ) . Apply ( input0 , input1 ) It is also worth noting that filter algorithms can be used as their own entities to make repetitive calls on them much like we showed with readers: import PVGeo # PSEUDOCODE: Typical use of a PVGeo filter: filt = PVGeo . suite . Filter ( ** kwargs ) output = filt . Apply ( inputDataObject ) # Change a parameter of the filter filt . SetParameter ( True ) # PSEUDOCODE filt . Update () # Make sure to update the output after changing a parameter # Request a different time step filt . UpdateTimeStep ( 6.0 )","title":"Python Usage"},{"location":"examples/about-examples/#source-algorithms","text":"A source takes input parameters from a user and generates a data object for visualization or export. In PVGeo , we have implemented the Model Building suite with many sources that allow for a user to specify attributes of a data set such as a model discretization and have a data source appear in the rendering environment alongside their other data for that scene.","title":"Source Algorithms"},{"location":"examples/about-examples/#paraview-usage_2","text":"Within ParaView, sources are available for selection directly from the GUI menus. All of the PVGeo sources are available under their own categories in the Sources menu.","title":"ParaView Usage"},{"location":"examples/about-examples/#python-usage_2","text":"Sources can be used like any algorithm in PVGeo and are typically called to immediately produce an output like below: import PVGeo # PSEUDOCODE: Typical use of a PVGeo source: output = PVGeo . suite . Source ( ** kwargs ) . Apply ()","title":"Python Usage"},{"location":"examples/about-examples/#writer-algorithms","text":"PVGeo writers take VTK data structures and write them out to the disk in a non-VTK formats that might be a standard for geoscientific data. PVGeo readers are often deployed with their complimentary writer equivalents such that data can be imported to the pipeline using readers, transformed using filters, then output to the same format in memory for use in an external processing library.","title":"Writer Algorithms"},{"location":"examples/about-examples/#paraview-usage_3","text":"Demonstrated in the following video, a user can select File -> Save Data in ParaView with a selected dataset then choose one of PVGeo \u2018s writers. The first 1 minute in the video demonstrates the Extract Topography then the video shows how to save a vtkRectilinearGrid and its attributes to the UBC Tensor Mesh/Model formats using a PVGeo writer.","title":"ParaView Usage"},{"location":"examples/about-examples/#python-usage_3","text":"Writers can be used like any algorithm in PVGeo and are typically called to immediately write out a data object like below. import PVGeo # PSEUDOCODE: Typical use of a PVGeo writer: writer = PVGeo . suite . Writer ( ** kwargs ) filename = 'test-writer.grd' writer . SetFileName ( filename ) writer . Write ( inputDataObject ) Writers: No Time Support Currently At the moment, the writers do not properly sink data on a time varying pipeline. This is a bug we are working to fix!","title":"Python Usage"},{"location":"examples/base/","text":"More to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Base"},{"location":"examples/contents/","text":"Example Contents \u00b6 Here is an outline of all the PVGeo example pages categorized by suite then by type of functionality. General Filters \u00b6 Point/Line Sets \u00b6 Add Cell Connectivity to Points : Generates a line of a series of points Append Cell Centers : Get the cell center coordinates as a 3-tuple array Convert Units : Convert the units of the spatial reference Extract Cell Centers : Extract the point data for a dataset\u2019s cell centers Extract Points : Extract points and attributes form a dataset with valid point data Iterate Over Points : Use a series of points for time varying a data scene Longitude/Latitude to UTM : Change reference frames Points to Tube : Generates a tube/cylinder from a series of points Rotate Points : Rotates the point data on an XY plane. Rotation Tool : A set of helpers for coordinate rotations Voxelize Points : Generates a set of voxels / creates a volume of data from a point set Mathematical Operations \u00b6 Array Math : Perform a mathematical operation between two arrays in a given data set Arrays to RGBA : Use a datasets arrays to create RGB colors and transparency Normalize Array : Perform a mathematical operation on a single array in a given dataset Percent Threshold : Threshold based on percentiles Slicing \u00b6 Many Slices Along Axis : Generate N slices of a dataset along a specified axis Many Slices Along Points : Generate N slices of a dataset along a series of points Slice Through Time : Generate a slice of a dataset that translates through time (animated) Slide Slice Along Points : Use a slider bar to move a slice along a series of points Table Operations \u00b6 Combine Tables : Combine two tables with the same number of rows Extract Array : Extract any data array fom a dataset to create a vtkTable containing that array. Reshape Table : Treat a table as a 2D array and reshape it to a differently sized 2D array Split Table On Array : Split a table based on values in a given array General Readers \u00b6 Binary/Serialized Data \u00b6 Binary Packed Data : Reads a 1D data array from a file containing binary numerical data Madagascar SSRSF : Read the Madagascar Single Stream RSF file format ASCII Data \u00b6 Delimited Text : A generic reader for ASCII / delimited data files. Frequently inherited. XYZ Files : A makeshift reader for delimited files with varying delimiters for data array titles Grid Tools \u00b6 Subsetting \u00b6 Extract Topography : Use a topography surface to add an active cells field to an input dataset Transformations \u00b6 Flip Grid Axii : Reverse data along any axis of an input grid Table to Uniform Grid : Generate a uniform grid from a table Translate Origin of Grid : Translate the corner / origin of an input grid File IO \u00b6 ESRI Grid Reader : Reader for ESRI\u2019s ASCII grid format Landsat Rasters : Read Landsat imagery/bands via XML metadata file Surfer Grids : Reader and writer for the Surfer grid format. Write Cell Centers : Write cell center coordinates with cell data arrays GSLIB & SGeMS \u00b6 GSLIB Table : Produce a vtkTable from a GSLib file SGeMS Grid : Produce a vtkImageData (uniform grid) from an SGeMS grid data file Model Building \u00b6 Create Earth Source : Create vtkPolyData with global continents Create Rectilinear Grid : Create a rectilinear grid / tensor mesh ( vtkRectilinearGrid ) Create Uniform Grid : Create a uniform grid ( vtkImageData ) Tunneling \u00b6 Animate TBM : Animate a tunnel boring machine UBC Mesh Tools \u00b6 Meshes and Models \u00b6 Append Model : Add a model attribute to a UBC style grid (supports time series) Read OcTree : Read an UBC OcTree grid file and a single time series model files Read Tensor Meshes : Read an UBC Tensor Mesh grid file and a single time series model files Data Files \u00b6 Read Gravity Observations : Read raw gravity gradient observations file Read Magnetics Observations : Read raw magnetics observations file Read Topography : Read XYZ topography file in UBC format","title":"Contents"},{"location":"examples/contents/#example-contents","text":"Here is an outline of all the PVGeo example pages categorized by suite then by type of functionality.","title":"Example Contents"},{"location":"examples/contents/#general-filters","text":"","title":"General Filters"},{"location":"examples/contents/#pointline-sets","text":"Add Cell Connectivity to Points : Generates a line of a series of points Append Cell Centers : Get the cell center coordinates as a 3-tuple array Convert Units : Convert the units of the spatial reference Extract Cell Centers : Extract the point data for a dataset\u2019s cell centers Extract Points : Extract points and attributes form a dataset with valid point data Iterate Over Points : Use a series of points for time varying a data scene Longitude/Latitude to UTM : Change reference frames Points to Tube : Generates a tube/cylinder from a series of points Rotate Points : Rotates the point data on an XY plane. Rotation Tool : A set of helpers for coordinate rotations Voxelize Points : Generates a set of voxels / creates a volume of data from a point set","title":"Point/Line Sets"},{"location":"examples/contents/#mathematical-operations","text":"Array Math : Perform a mathematical operation between two arrays in a given data set Arrays to RGBA : Use a datasets arrays to create RGB colors and transparency Normalize Array : Perform a mathematical operation on a single array in a given dataset Percent Threshold : Threshold based on percentiles","title":"Mathematical Operations"},{"location":"examples/contents/#slicing","text":"Many Slices Along Axis : Generate N slices of a dataset along a specified axis Many Slices Along Points : Generate N slices of a dataset along a series of points Slice Through Time : Generate a slice of a dataset that translates through time (animated) Slide Slice Along Points : Use a slider bar to move a slice along a series of points","title":"Slicing"},{"location":"examples/contents/#table-operations","text":"Combine Tables : Combine two tables with the same number of rows Extract Array : Extract any data array fom a dataset to create a vtkTable containing that array. Reshape Table : Treat a table as a 2D array and reshape it to a differently sized 2D array Split Table On Array : Split a table based on values in a given array","title":"Table Operations"},{"location":"examples/contents/#general-readers","text":"","title":"General Readers"},{"location":"examples/contents/#binaryserialized-data","text":"Binary Packed Data : Reads a 1D data array from a file containing binary numerical data Madagascar SSRSF : Read the Madagascar Single Stream RSF file format","title":"Binary/Serialized Data"},{"location":"examples/contents/#ascii-data","text":"Delimited Text : A generic reader for ASCII / delimited data files. Frequently inherited. XYZ Files : A makeshift reader for delimited files with varying delimiters for data array titles","title":"ASCII Data"},{"location":"examples/contents/#grid-tools","text":"","title":"Grid Tools"},{"location":"examples/contents/#subsetting","text":"Extract Topography : Use a topography surface to add an active cells field to an input dataset","title":"Subsetting"},{"location":"examples/contents/#transformations","text":"Flip Grid Axii : Reverse data along any axis of an input grid Table to Uniform Grid : Generate a uniform grid from a table Translate Origin of Grid : Translate the corner / origin of an input grid","title":"Transformations"},{"location":"examples/contents/#file-io","text":"ESRI Grid Reader : Reader for ESRI\u2019s ASCII grid format Landsat Rasters : Read Landsat imagery/bands via XML metadata file Surfer Grids : Reader and writer for the Surfer grid format. Write Cell Centers : Write cell center coordinates with cell data arrays","title":"File IO"},{"location":"examples/contents/#gslib-sgems","text":"GSLIB Table : Produce a vtkTable from a GSLib file SGeMS Grid : Produce a vtkImageData (uniform grid) from an SGeMS grid data file","title":"GSLIB &amp; SGeMS"},{"location":"examples/contents/#model-building","text":"Create Earth Source : Create vtkPolyData with global continents Create Rectilinear Grid : Create a rectilinear grid / tensor mesh ( vtkRectilinearGrid ) Create Uniform Grid : Create a uniform grid ( vtkImageData )","title":"Model Building"},{"location":"examples/contents/#tunneling","text":"Animate TBM : Animate a tunnel boring machine","title":"Tunneling"},{"location":"examples/contents/#ubc-mesh-tools","text":"","title":"UBC Mesh Tools"},{"location":"examples/contents/#meshes-and-models","text":"Append Model : Add a model attribute to a UBC style grid (supports time series) Read OcTree : Read an UBC OcTree grid file and a single time series model files Read Tensor Meshes : Read an UBC Tensor Mesh grid file and a single time series model files","title":"Meshes and Models"},{"location":"examples/contents/#data-files","text":"Read Gravity Observations : Read raw gravity gradient observations file Read Magnetics Observations : Read raw magnetics observations file Read Topography : Read XYZ topography file in UBC format","title":"Data Files"},{"location":"examples/template/","text":"Info This example will demonstrate how to \u2026 Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at XXXXX \u2018s code docs here . import numpy as np import vtk from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo.filters import CombineTables ################################## # Create some input data ################################## # Now use the filter:","title":"Template"},{"location":"examples/template/#overview","text":"","title":"Overview"},{"location":"examples/template/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/template/#python-example","text":"Take a look at XXXXX \u2018s code docs here . import numpy as np import vtk from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo.filters import CombineTables ################################## # Create some input data ################################## # Now use the filter:","title":"Python Example"},{"location":"examples/filters-general/add-cell-connectivity-to-points/","text":"Info This example will demonstrate how to add connectivity along some arbitrary set of points to generate a line or polyline. Warning The Add Cell Connectivity To Points filter uses the SciPy python package. You may get an error if you do not have SciPy linked to ParaView Python. To work around this, make sure the Use nearest nbr parameter is not checked. Since the points file we give you in this example is in sequential order, this will not matter. See details to learn more about enabling the SciPy package in pvpython . Overview \u00b6 This filter will add linear cell connectivity between scattered points. You have the option to add VTK_LINE or VTK_POLYLINE connectivity. VTK_LINE connectivity makes a straight line between the points in order (either in the order by index or using a nearest neighbor calculation). The VTK_POLYLINE adds polyline connectivity between all points as one spline (either in the order by index or using a nearest neighbor calculation). ParaView Example \u00b6 First, lets generate some data on the ParaView pipeline. For this example, we want to generated a series of scattered points that might make up a path using a Programmable Source . Select Sources->Alphabetical->Programmable Source then paste the following script in the source\u2019s Script field: import numpy as np from PVGeo import pointsToPolyData def path1 ( y ): \"\"\"Equation: x = a(y-h)^2 + k\"\"\" a = - 110.0 / 160.0 ** 2 x = a * y ** 2 + 110.0 idxs = np . argwhere ( x > 0 ) return x [ idxs ][:, 0 ], y [ idxs ][:, 0 ] x , y = path1 ( np . arange ( 0.0 , 200.0 , 25.0 )) zo = np . linspace ( 9.0 , 11.0 , num = len ( y )) coords = np . vstack (( x , y , zo )) . T # Shuffle points to demonstrate value of Nearest Neighbor np . random . shuffle ( coords ) pdo = self . GetOutput () pdo . ShallowCopy ( pointsToPolyData ( coords )) Note These points are similar to the points used in the file given with the Many Slices Along Points Example except we shuffle them to make use of the nearest neighbor approximation. Apply the Filter \u00b6 Now that you have the points generated on the pipeline, lets go ahead and apply the Add Cell Connectivity To Points filter from Filters->PVGeo: General Filters->Add Cell Connectivity To Points . Go ahead and click Apply . The output data should look really wacky and incorrectly built like the image below; this is good. Remember that in the script given above we shuffle the points to demonstrate that the points make a useable line but we need to reconstruct the order of the points. We do this by selecting the Use Nearest Nbr Approx checkbox; this will ensure that a useable path is generate from the points. Go ahead and select the check box then reapply the filter. Now it looks good (see image below)! Python Example \u00b6 Take a look at AddCellConnToPoints \u2018 code docs here import numpy as np from PVGeo import pointsToPolyData from PVGeo.filters import AddCellConnToPoints ############################################ ######### GENERATE SOME POINT DATA ######### def path1 ( y ): \"\"\"Equation: x = a(y-h)^2 + k\"\"\" a = - 110.0 / 160.0 ** 2 x = a * y ** 2 + 110.0 idxs = np . argwhere ( x > 0 ) return x [ idxs ][:, 0 ], y [ idxs ][:, 0 ] x , y = path1 ( np . arange ( 0.0 , 200.0 , 25.0 )) zo = np . linspace ( 9.0 , 11.0 , num = len ( y )) coords = np . vstack (( x , y , zo )) . T # Shuffle points to demonstrate value of Nearest Neighbor np . random . shuffle ( coords ) # Make a VTK data object for the filter to use vtkPoints = pointsToPolyData ( coords ) ############################################ # Use the filter: Here is vtkPolyData containing the connected line: line = AddCellConnToPoints ( nearestNbr = True ) . Apply ( vtkPoints )","title":"Add Cell Connectivity to Points"},{"location":"examples/filters-general/add-cell-connectivity-to-points/#overview","text":"This filter will add linear cell connectivity between scattered points. You have the option to add VTK_LINE or VTK_POLYLINE connectivity. VTK_LINE connectivity makes a straight line between the points in order (either in the order by index or using a nearest neighbor calculation). The VTK_POLYLINE adds polyline connectivity between all points as one spline (either in the order by index or using a nearest neighbor calculation).","title":"Overview"},{"location":"examples/filters-general/add-cell-connectivity-to-points/#paraview-example","text":"First, lets generate some data on the ParaView pipeline. For this example, we want to generated a series of scattered points that might make up a path using a Programmable Source . Select Sources->Alphabetical->Programmable Source then paste the following script in the source\u2019s Script field: import numpy as np from PVGeo import pointsToPolyData def path1 ( y ): \"\"\"Equation: x = a(y-h)^2 + k\"\"\" a = - 110.0 / 160.0 ** 2 x = a * y ** 2 + 110.0 idxs = np . argwhere ( x > 0 ) return x [ idxs ][:, 0 ], y [ idxs ][:, 0 ] x , y = path1 ( np . arange ( 0.0 , 200.0 , 25.0 )) zo = np . linspace ( 9.0 , 11.0 , num = len ( y )) coords = np . vstack (( x , y , zo )) . T # Shuffle points to demonstrate value of Nearest Neighbor np . random . shuffle ( coords ) pdo = self . GetOutput () pdo . ShallowCopy ( pointsToPolyData ( coords )) Note These points are similar to the points used in the file given with the Many Slices Along Points Example except we shuffle them to make use of the nearest neighbor approximation.","title":"ParaView Example"},{"location":"examples/filters-general/add-cell-connectivity-to-points/#apply-the-filter","text":"Now that you have the points generated on the pipeline, lets go ahead and apply the Add Cell Connectivity To Points filter from Filters->PVGeo: General Filters->Add Cell Connectivity To Points . Go ahead and click Apply . The output data should look really wacky and incorrectly built like the image below; this is good. Remember that in the script given above we shuffle the points to demonstrate that the points make a useable line but we need to reconstruct the order of the points. We do this by selecting the Use Nearest Nbr Approx checkbox; this will ensure that a useable path is generate from the points. Go ahead and select the check box then reapply the filter. Now it looks good (see image below)!","title":"Apply the Filter"},{"location":"examples/filters-general/add-cell-connectivity-to-points/#python-example","text":"Take a look at AddCellConnToPoints \u2018 code docs here import numpy as np from PVGeo import pointsToPolyData from PVGeo.filters import AddCellConnToPoints ############################################ ######### GENERATE SOME POINT DATA ######### def path1 ( y ): \"\"\"Equation: x = a(y-h)^2 + k\"\"\" a = - 110.0 / 160.0 ** 2 x = a * y ** 2 + 110.0 idxs = np . argwhere ( x > 0 ) return x [ idxs ][:, 0 ], y [ idxs ][:, 0 ] x , y = path1 ( np . arange ( 0.0 , 200.0 , 25.0 )) zo = np . linspace ( 9.0 , 11.0 , num = len ( y )) coords = np . vstack (( x , y , zo )) . T # Shuffle points to demonstrate value of Nearest Neighbor np . random . shuffle ( coords ) # Make a VTK data object for the filter to use vtkPoints = pointsToPolyData ( coords ) ############################################ # Use the filter: Here is vtkPolyData containing the connected line: line = AddCellConnToPoints ( nearestNbr = True ) . Apply ( vtkPoints )","title":"Python Example"},{"location":"examples/filters-general/append-cell-centers/","text":"Info This example will demonstrate how to append a dataset\u2019s cell centers as a length 3 tuple array. Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at AppendCellCenters \u2018 code docs here","title":"Append Cell Centers"},{"location":"examples/filters-general/append-cell-centers/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/append-cell-centers/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/append-cell-centers/#python-example","text":"Take a look at AppendCellCenters \u2018 code docs here","title":"Python Example"},{"location":"examples/filters-general/array-math/","text":"Info This example will demonstrate how to to powerful a mathematical operation between to input arrays for any given source. Overview \u00b6 This filter allows the user to select two input data arrays on which to perform math operations. The input arrays are used in their order of selection for the operations. ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at ArrayMath \u2018s code docs here import numpy as np import vtk from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo.filters import ArrayMath # Create some input data. This can be any `vtkDataObject` inp = vtk . vtkTable () # Populate the tables n = 400 arr0 = np . random . random ( n ) arr1 = np . random . random ( n ) inp . AddColumn ( PVGeo . convertArray ( arr0 , 'Array 0' )) inp . AddColumn ( PVGeo . convertArray ( arr1 , 'Array 1' )) # Use the filter: f = ArrayMath ( operation = 'add' , newName = 'foo' ) # Now get the result output = f . Apply ( inp , 'Array 0' , 'Array 1' ) wout = dsa . WrapDataObject ( output ) arr = wout . RowData [ 'foo' ] assert ( np . allclose ( arr , arr0 + arr1 )) # Use a custom math operation: def power ( arr0 , arr1 ): return arr0 ** arr1 # Use filter generated above f . SetOperation ( power ) f . SetNewArrayName ( 'powered' ) f . Update () # Now get the result output = f . GetOutput () print ( output )","title":"Array Math"},{"location":"examples/filters-general/array-math/#overview","text":"This filter allows the user to select two input data arrays on which to perform math operations. The input arrays are used in their order of selection for the operations.","title":"Overview"},{"location":"examples/filters-general/array-math/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/array-math/#python-example","text":"Take a look at ArrayMath \u2018s code docs here import numpy as np import vtk from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo.filters import ArrayMath # Create some input data. This can be any `vtkDataObject` inp = vtk . vtkTable () # Populate the tables n = 400 arr0 = np . random . random ( n ) arr1 = np . random . random ( n ) inp . AddColumn ( PVGeo . convertArray ( arr0 , 'Array 0' )) inp . AddColumn ( PVGeo . convertArray ( arr1 , 'Array 1' )) # Use the filter: f = ArrayMath ( operation = 'add' , newName = 'foo' ) # Now get the result output = f . Apply ( inp , 'Array 0' , 'Array 1' ) wout = dsa . WrapDataObject ( output ) arr = wout . RowData [ 'foo' ] assert ( np . allclose ( arr , arr0 + arr1 )) # Use a custom math operation: def power ( arr0 , arr1 ): return arr0 ** arr1 # Use filter generated above f . SetOperation ( power ) f . SetNewArrayName ( 'powered' ) f . Update () # Now get the result output = f . GetOutput () print ( output )","title":"Python Example"},{"location":"examples/filters-general/arrays-to-rgba/","text":"Arrays to RGBA \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Take a look at ArraysToRGBA \u2018s code docs here","title":"Arrays to RGBA"},{"location":"examples/filters-general/arrays-to-rgba/#arrays-to-rgba","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Take a look at ArraysToRGBA \u2018s code docs here","title":"Arrays to RGBA"},{"location":"examples/filters-general/combine-tables/","text":"Info This example will demonstrate how to to merge to vtkTable objects with the same number of rows into a single vtkTable . ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at CombineTables \u2018 code docs here import numpy as np import vtk from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo.filters import CombineTables ################################## # Create some input tables t0 = vtk . vtkTable () t1 = vtk . vtkTable () # Populate the tables n = 100 titles = ( 'Array 0' , 'Array 1' , 'Array 2' ) arr0 = np . random . random ( n ) # Table 0 arr1 = np . random . random ( n ) # Table 0 t0 . AddColumn ( PVGeo . convertArray ( arr0 , titles [ 0 ])) t0 . AddColumn ( PVGeo . convertArray ( arr1 , titles [ 1 ])) arr2 = np . random . random ( n ) # Table 1 t1 . AddColumn ( PVGeo . convertArray ( arr2 , titles [ 2 ])) arrs = [ arr0 , arr1 , arr2 ] ################################## # Now use the `CombineTables` filter: output = CombineTables () . Apply ( t0 , t1 ) # Here I verify the result wpdi = dsa . WrapDataObject ( output ) for i in range ( len ( titles )): arr = wpdi . RowData [ titles [ i ]] assert ( np . allclose ( arr , arrs [ i ], rtol = 0.0001 ))","title":"Combine Tables"},{"location":"examples/filters-general/combine-tables/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/combine-tables/#python-example","text":"Take a look at CombineTables \u2018 code docs here import numpy as np import vtk from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo.filters import CombineTables ################################## # Create some input tables t0 = vtk . vtkTable () t1 = vtk . vtkTable () # Populate the tables n = 100 titles = ( 'Array 0' , 'Array 1' , 'Array 2' ) arr0 = np . random . random ( n ) # Table 0 arr1 = np . random . random ( n ) # Table 0 t0 . AddColumn ( PVGeo . convertArray ( arr0 , titles [ 0 ])) t0 . AddColumn ( PVGeo . convertArray ( arr1 , titles [ 1 ])) arr2 = np . random . random ( n ) # Table 1 t1 . AddColumn ( PVGeo . convertArray ( arr2 , titles [ 2 ])) arrs = [ arr0 , arr1 , arr2 ] ################################## # Now use the `CombineTables` filter: output = CombineTables () . Apply ( t0 , t1 ) # Here I verify the result wpdi = dsa . WrapDataObject ( output ) for i in range ( len ( titles )): arr = wpdi . RowData [ titles [ i ]] assert ( np . allclose ( arr , arrs [ i ], rtol = 0.0001 ))","title":"Python Example"},{"location":"examples/filters-general/convert-units/","text":"Info This example will demonstrate how to convert the units of the spatial reference for a given dataset. Currently this only support meter <-> feet conversion but can very easily be expanded to any conversions. Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at ConvertUnits \u2018 code docs here","title":"Convert Units"},{"location":"examples/filters-general/convert-units/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/convert-units/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/convert-units/#python-example","text":"Take a look at ConvertUnits \u2018 code docs here","title":"Python Example"},{"location":"examples/filters-general/extract-array/","text":"Info This example will demonstrate how to extract an array from any input data set to make a vtkTable of that single data array Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at ExtractArray \u2018s code docs here import PVGeo from PVGeo.filters import ExtractArray # Create input data grd = PVGeo . model_build . CreateTensorMesh () . Apply () # Construct the filter filt = ExtractArray () # Define the array to extract # Apply the filter on the input table = filt . Apply ( grd , 'Random Data' ) print ( table )","title":"Extract Array"},{"location":"examples/filters-general/extract-array/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/extract-array/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/extract-array/#python-example","text":"Take a look at ExtractArray \u2018s code docs here import PVGeo from PVGeo.filters import ExtractArray # Create input data grd = PVGeo . model_build . CreateTensorMesh () . Apply () # Construct the filter filt = ExtractArray () # Define the array to extract # Apply the filter on the input table = filt . Apply ( grd , 'Random Data' ) print ( table )","title":"Python Example"},{"location":"examples/filters-general/extract-cell-centers/","text":"Info This example will demonstrate how to extract the cell centers of a data set. Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at ExtractCellCenters \u2018 code docs here","title":"Extract Cell Centers"},{"location":"examples/filters-general/extract-cell-centers/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/extract-cell-centers/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/extract-cell-centers/#python-example","text":"Take a look at ExtractCellCenters \u2018 code docs here","title":"Python Example"},{"location":"examples/filters-general/extract-points/","text":"Info This example will demonstrate how to extract the points and PointData of any input data set that has valid PointData into a vtkPolyData object. Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at ExtractPoints \u2018 code docs here import PVGeo from PVGeo.filters import ExtractPoints ##################################### # Have some input data source with valid PointData source = PVGeo . model_build . GlobeSource () source . Update () data = source . GetOutput () ##################################### # Apply the filter: polyData = ExtractPoints () . Apply ( data ) # Get and use the result: print ( polyData )","title":"Extract Points"},{"location":"examples/filters-general/extract-points/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/extract-points/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/extract-points/#python-example","text":"Take a look at ExtractPoints \u2018 code docs here import PVGeo from PVGeo.filters import ExtractPoints ##################################### # Have some input data source with valid PointData source = PVGeo . model_build . GlobeSource () source . Update () data = source . GetOutput () ##################################### # Apply the filter: polyData = ExtractPoints () . Apply ( data ) # Get and use the result: print ( polyData )","title":"Python Example"},{"location":"examples/filters-general/iterate-over-points/","text":"Info This example will demonstrate how to iterate of a series of points in a time varying manner. Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at IterateOverPoints \u2018 code docs here","title":"Iterate Over Points"},{"location":"examples/filters-general/iterate-over-points/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/iterate-over-points/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/iterate-over-points/#python-example","text":"Take a look at IterateOverPoints \u2018 code docs here","title":"Python Example"},{"location":"examples/filters-general/lonlat-to-utm/","text":"Info This example will demonstrate how to convert the coordinate system of points to UTM. Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at LonLatToUTM \u2018s code docs here","title":"Longitude/Latitude to UTM"},{"location":"examples/filters-general/lonlat-to-utm/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/lonlat-to-utm/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/lonlat-to-utm/#python-example","text":"Take a look at LonLatToUTM \u2018s code docs here","title":"Python Example"},{"location":"examples/filters-general/many-slices-along-axis/","text":"Info This example will demonstrate how to slice an input data set many times along an axis. Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page PVGeo: Many Slices Along Axis Filter from Bane Sullivan on Vimeo . Python Example \u00b6 Take a look at ManySlicesAlongAxis \u2018 code docs here Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Many Slices Along Axis"},{"location":"examples/filters-general/many-slices-along-axis/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/many-slices-along-axis/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page PVGeo: Many Slices Along Axis Filter from Bane Sullivan on Vimeo .","title":"ParaView Example"},{"location":"examples/filters-general/many-slices-along-axis/#python-example","text":"Take a look at ManySlicesAlongAxis \u2018 code docs here Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Python Example"},{"location":"examples/filters-general/many-slices-along-points/","text":"Info This example will demonstrate how to slice a 3D data source along some arbitrary line or sequence of points specified in another data source to have many slices of the 3D data perpendicular to that travel path. Warning The Many Slices Along Points filter uses the SciPy python package. You may get an error if you do not have SciPy linked to ParaView Python. To work around this, make sure the Use nearest nbr parameter is not checked. Since the points file we give you in this example is in sequential order, this will not matter. See details to learn more about enabling the SciPy package in pvpython . Overview \u00b6 Sometimes, we desire to take a path through a model and construct various slices along that path. This example will outline a filter we have developed to take some 3D data set on the pipeline and construct various slices of that model along an input path. The slices will be perpendicular to that path at specified intervals. In this example, we also demonstrate a filter that comes native in ParaView to slice that entire model along the travel path to have a single warped slice. Load the Data \u00b6 First, lets load some data onto the ParaView pipeline. For this example, we want to use a 3D model of rock density in a homogeneous layer of a carbonate reservoir found on this website . You can download the model in the SGeMS gridded data format in the link below this paragraph. Download Data Description Data File 1: \u2018topexample.sgems\u2019 Original source: http://www.trainingimages.org/training-images-library.html Reader to Use: SGeMS Grid from the PVGeo repo found here Description: This data file is the 3D model that we will slice through Data File 2: \u2018points.csv\u2019 Reader to Use: Delimited Text reader native to ParaView Description: You will perform a Table to Points filter on this data source and it holds the points for which we will construct a path to slice the 3D model. Prepare the Data \u00b6 Now that you have the two data files loaded onto the pipeline in ParaView. First, select the points table on the pipeline that you loaded directly from the data file and apply a Table to Points filter on this data source. Select the proper parameters and apply this filter. Now display these points in the render view by clicking the render view then enabling the eyeball icon next to this filter on the pipeline. The points should appear inside of the data volume from the \u2018topexample.sgems\u2019 source. Filters applied to the points Table to Points: Match the columns to the appropriate fields in the parameters. Apply the Filter \u00b6 Now we can use the Many Slices Along Points filter by clicking on one of the data objects on the pipeline and selecting Many Slices Along Points from the Filters -> PVGeo: General Filters -> Many Slices Along Points . A dialog should appear prompting you to select the two inputs for the filter: specify the \u2018topexample.sgems\u2019 source as the Dataset input and the points \u2018TableToPoints1\u2019 as the Points input to that filter and click apply. That\u2019s it! The filter should be applied and you can fine tune the number of slices using the slider bar next to the Number of Slices property on the filter properties panel. Going a Step Further \u00b6 We can also apply a Slice Along Poly Line filter that is native to ParaView to have one warped slice of the model along the poly line we created. Specify the \u2018topexample.sgems\u2019 source as the Dataset input and the points \u2018TableToPoints1\u2019 as the Poly Line input to that filter and click apply. Result \u00b6 Final Data Scene Take a look at ManySlicesAlongPoints \u2018 code docs here","title":"Many Slices Along Points"},{"location":"examples/filters-general/many-slices-along-points/#overview","text":"Sometimes, we desire to take a path through a model and construct various slices along that path. This example will outline a filter we have developed to take some 3D data set on the pipeline and construct various slices of that model along an input path. The slices will be perpendicular to that path at specified intervals. In this example, we also demonstrate a filter that comes native in ParaView to slice that entire model along the travel path to have a single warped slice.","title":"Overview"},{"location":"examples/filters-general/many-slices-along-points/#load-the-data","text":"First, lets load some data onto the ParaView pipeline. For this example, we want to use a 3D model of rock density in a homogeneous layer of a carbonate reservoir found on this website . You can download the model in the SGeMS gridded data format in the link below this paragraph. Download Data Description Data File 1: \u2018topexample.sgems\u2019 Original source: http://www.trainingimages.org/training-images-library.html Reader to Use: SGeMS Grid from the PVGeo repo found here Description: This data file is the 3D model that we will slice through Data File 2: \u2018points.csv\u2019 Reader to Use: Delimited Text reader native to ParaView Description: You will perform a Table to Points filter on this data source and it holds the points for which we will construct a path to slice the 3D model.","title":"Load the Data"},{"location":"examples/filters-general/many-slices-along-points/#prepare-the-data","text":"Now that you have the two data files loaded onto the pipeline in ParaView. First, select the points table on the pipeline that you loaded directly from the data file and apply a Table to Points filter on this data source. Select the proper parameters and apply this filter. Now display these points in the render view by clicking the render view then enabling the eyeball icon next to this filter on the pipeline. The points should appear inside of the data volume from the \u2018topexample.sgems\u2019 source. Filters applied to the points Table to Points: Match the columns to the appropriate fields in the parameters.","title":"Prepare the Data"},{"location":"examples/filters-general/many-slices-along-points/#apply-the-filter","text":"Now we can use the Many Slices Along Points filter by clicking on one of the data objects on the pipeline and selecting Many Slices Along Points from the Filters -> PVGeo: General Filters -> Many Slices Along Points . A dialog should appear prompting you to select the two inputs for the filter: specify the \u2018topexample.sgems\u2019 source as the Dataset input and the points \u2018TableToPoints1\u2019 as the Points input to that filter and click apply. That\u2019s it! The filter should be applied and you can fine tune the number of slices using the slider bar next to the Number of Slices property on the filter properties panel.","title":"Apply the Filter"},{"location":"examples/filters-general/many-slices-along-points/#going-a-step-further","text":"We can also apply a Slice Along Poly Line filter that is native to ParaView to have one warped slice of the model along the poly line we created. Specify the \u2018topexample.sgems\u2019 source as the Dataset input and the points \u2018TableToPoints1\u2019 as the Poly Line input to that filter and click apply.","title":"Going a Step Further"},{"location":"examples/filters-general/many-slices-along-points/#result","text":"Final Data Scene Take a look at ManySlicesAlongPoints \u2018 code docs here","title":"Result"},{"location":"examples/filters-general/normalize-array/","text":"Info This example will demonstrate how to perform a normalization or any custom mathematical operation on a single data array for an input data set. Overview \u00b6 This filter allow the user to select an array from the input data set to be normalized. The filter will append another array to that data set for the output. The user can specify how they want to rename the array, can choose a multiplier, and can choose from two types of common normalizations: Feature Scaling and Standard Score. ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at NormalizeArray \u2018s code docs here import numpy as np import vtk from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo.filters import NormalizeArray ################## # Create some input data. this can be any `vtkDataObject` inp = vtk . vtkTable () # Populate the data n = 400 title = 'Array 0' arr = np . random . random ( n ) # Table 0 inp . AddColumn ( PVGeo . convertArray ( arr , title )) ################### # Apply the filter f = NormalizeArray ( normalization = 'feature_scale' , newName = 'foo' ) output = f . Apply ( inp , title ) # Check out the result wout = dsa . WrapDataObject ( output ) normArr = wout . RowData [ 'foo' ] print ( normArr )","title":"Normalize Array"},{"location":"examples/filters-general/normalize-array/#overview","text":"This filter allow the user to select an array from the input data set to be normalized. The filter will append another array to that data set for the output. The user can specify how they want to rename the array, can choose a multiplier, and can choose from two types of common normalizations: Feature Scaling and Standard Score.","title":"Overview"},{"location":"examples/filters-general/normalize-array/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/normalize-array/#python-example","text":"Take a look at NormalizeArray \u2018s code docs here import numpy as np import vtk from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo.filters import NormalizeArray ################## # Create some input data. this can be any `vtkDataObject` inp = vtk . vtkTable () # Populate the data n = 400 title = 'Array 0' arr = np . random . random ( n ) # Table 0 inp . AddColumn ( PVGeo . convertArray ( arr , title )) ################### # Apply the filter f = NormalizeArray ( normalization = 'feature_scale' , newName = 'foo' ) output = f . Apply ( inp , title ) # Check out the result wout = dsa . WrapDataObject ( output ) normArr = wout . RowData [ 'foo' ] print ( normArr )","title":"Python Example"},{"location":"examples/filters-general/percent-threshold/","text":"Info This example will demonstrate how to threshold a dataset by percentiles. Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at PercentThreshold \u2018s code docs here","title":"Percent Threshold"},{"location":"examples/filters-general/percent-threshold/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/percent-threshold/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/percent-threshold/#python-example","text":"Take a look at PercentThreshold \u2018s code docs here","title":"Python Example"},{"location":"examples/filters-general/points-to-tube/","text":"Info This example will demonstrate how to to build a tube from a set of points in vtkPolyData . Overview \u00b6 Takes points from a vtkPolyData object and constructs a line of those points then builds a polygonal tube around that line with some specified radius and number of sides. ParaView Example \u00b6 First, lets generate some data on the ParaView pipeline. For this example, we want to generated a series of scattered points that might make up a path using a Programmable Source . Select Sources->Alphabetical->Programmable Source then paste the following script in the source\u2019s Script field: import numpy as np from PVGeo import pointsToPolyData def path1 ( y ): \"\"\"Equation: x = a(y-h)^2 + k\"\"\" a = - 110.0 / 160.0 ** 2 x = a * y ** 2 + 110.0 idxs = np . argwhere ( x > 0 ) return x [ idxs ][:, 0 ], y [ idxs ][:, 0 ] x , y = path1 ( np . arange ( 0.0 , 200.0 , 25.0 )) zo = np . linspace ( 9.0 , 11.0 , num = len ( y )) coords = np . vstack (( x , y , zo )) . T # Shuffle points to demonstrate value of Nearest Neighbor np . random . shuffle ( coords ) pdo = self . GetOutput () pdo . ShallowCopy ( pointsToPolyData ( coords )) Note These points are similar to the points used in the file given with the Many Slices Along Points Example except we shuffle them to make use of the nearest neighbor approximation. Apply the Filter \u00b6 Now that you have the points generated on the pipeline, lets go ahead and apply the Points to Tube filter from Filters->PVGeo: General Filters->Points to Tube . Change the radius to 3 and go ahead and click Apply . The output data should look really wacky and incorrectly built like the image below; this is good. Remember that in the script given above we shuffle the points to demonstrate that the points make a useable line but we need to reconstruct the order of the points. We do this by selecting the Use Nearest Nbr Approx checkbox; this will ensure that a useable path is generate from the points. Go ahead and select the check box then reapply the filter. Now it looks good (see image below)! Python Example \u00b6 Take a look at PointsToTube \u2018s code docs here import numpy as np from PVGeo import pointsToPolyData from PVGeo.filters import PointsToTube ############################################ ######### GENERATE SOME POINT DATA ######### def path1 ( y ): \"\"\"Equation: x = a(y-h)^2 + k\"\"\" a = - 110.0 / 160.0 ** 2 x = a * y ** 2 + 110.0 idxs = np . argwhere ( x > 0 ) return x [ idxs ][:, 0 ], y [ idxs ][:, 0 ] x , y = path1 ( np . arange ( 0.0 , 200.0 , 25.0 )) zo = np . linspace ( 9.0 , 11.0 , num = len ( y )) coords = np . vstack (( x , y , zo )) . T # Shuffle points to demonstrate value of Nearest Neighbor np . random . shuffle ( coords ) # Make a VTK data object for the filter to use vtkPoints = pointsToPolyData ( coords ) ############################################ # Use the filter: here is vtkPolyData containing the connected line tube = PointsToTube ( nearestNbr = True ) . Apply ( vtkPoints ) print ( tube )","title":"Points to Tube"},{"location":"examples/filters-general/points-to-tube/#overview","text":"Takes points from a vtkPolyData object and constructs a line of those points then builds a polygonal tube around that line with some specified radius and number of sides.","title":"Overview"},{"location":"examples/filters-general/points-to-tube/#paraview-example","text":"First, lets generate some data on the ParaView pipeline. For this example, we want to generated a series of scattered points that might make up a path using a Programmable Source . Select Sources->Alphabetical->Programmable Source then paste the following script in the source\u2019s Script field: import numpy as np from PVGeo import pointsToPolyData def path1 ( y ): \"\"\"Equation: x = a(y-h)^2 + k\"\"\" a = - 110.0 / 160.0 ** 2 x = a * y ** 2 + 110.0 idxs = np . argwhere ( x > 0 ) return x [ idxs ][:, 0 ], y [ idxs ][:, 0 ] x , y = path1 ( np . arange ( 0.0 , 200.0 , 25.0 )) zo = np . linspace ( 9.0 , 11.0 , num = len ( y )) coords = np . vstack (( x , y , zo )) . T # Shuffle points to demonstrate value of Nearest Neighbor np . random . shuffle ( coords ) pdo = self . GetOutput () pdo . ShallowCopy ( pointsToPolyData ( coords )) Note These points are similar to the points used in the file given with the Many Slices Along Points Example except we shuffle them to make use of the nearest neighbor approximation.","title":"ParaView Example"},{"location":"examples/filters-general/points-to-tube/#apply-the-filter","text":"Now that you have the points generated on the pipeline, lets go ahead and apply the Points to Tube filter from Filters->PVGeo: General Filters->Points to Tube . Change the radius to 3 and go ahead and click Apply . The output data should look really wacky and incorrectly built like the image below; this is good. Remember that in the script given above we shuffle the points to demonstrate that the points make a useable line but we need to reconstruct the order of the points. We do this by selecting the Use Nearest Nbr Approx checkbox; this will ensure that a useable path is generate from the points. Go ahead and select the check box then reapply the filter. Now it looks good (see image below)!","title":"Apply the Filter"},{"location":"examples/filters-general/points-to-tube/#python-example","text":"Take a look at PointsToTube \u2018s code docs here import numpy as np from PVGeo import pointsToPolyData from PVGeo.filters import PointsToTube ############################################ ######### GENERATE SOME POINT DATA ######### def path1 ( y ): \"\"\"Equation: x = a(y-h)^2 + k\"\"\" a = - 110.0 / 160.0 ** 2 x = a * y ** 2 + 110.0 idxs = np . argwhere ( x > 0 ) return x [ idxs ][:, 0 ], y [ idxs ][:, 0 ] x , y = path1 ( np . arange ( 0.0 , 200.0 , 25.0 )) zo = np . linspace ( 9.0 , 11.0 , num = len ( y )) coords = np . vstack (( x , y , zo )) . T # Shuffle points to demonstrate value of Nearest Neighbor np . random . shuffle ( coords ) # Make a VTK data object for the filter to use vtkPoints = pointsToPolyData ( coords ) ############################################ # Use the filter: here is vtkPolyData containing the connected line tube = PointsToTube ( nearestNbr = True ) . Apply ( vtkPoints ) print ( tube )","title":"Python Example"},{"location":"examples/filters-general/reshape-table/","text":"Info This example will demonstrate how to reshape an input table as though it were a 2D array. Overview \u00b6 This filter will take a vtkTable object and reshape it. This filter essentially treats vtkTable s as 2D matrices and reshapes them using numpy . reshape in a C contiguous manner. Unfortunately, data fields will be renamed arbitrarily because VTK data arrays require a name. ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at ReshapeTable \u2018s code docs here import numpy as np import vtk from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo.filters import ReshapeTable # Create some input table t0 = vtk . vtkTable () # Populate the tables arrs = [ None , None , None ] n = 400 ncols = 2 nrows = int ( n * len ( arrs ) / ncols ) titles = ( 'Array 0' , 'Array 1' , 'Array 2' ) arrs [ 0 ] = np . random . random ( n ) arrs [ 1 ] = np . random . random ( n ) arrs [ 2 ] = np . random . random ( n ) t0 . AddColumn ( PVGeo . convertArray ( arrs [ 0 ], titles [ 0 ])) t0 . AddColumn ( PVGeo . convertArray ( arrs [ 1 ], titles [ 1 ])) t0 . AddColumn ( PVGeo . convertArray ( arrs [ 2 ], titles [ 2 ])) # Use the filter to reshape the table order = 'F' newtitles = [ 'Title %d ' % i for i in range ( ncols )] output = ReshapeTable ( order = order , ncols = ncols , nrows = nrows , names = newtitles ) . Apply ( t0 ) # Check the output against NumPy wpdi = dsa . WrapDataObject ( output ) tarr = np . zeros (( nrows , ncols )) for i in range ( ncols ): tarr [:, i ] = wpdi . RowData [ i ] arrs = np . array ( arrs ) . T arrs = arrs . flatten () arrs = np . reshape ( arrs , ( nrows , ncols ), order = order ) assert ( tarr . shape == arrs . shape ) assert ( np . allclose ( tarr , arrs ))","title":"Reshape Table"},{"location":"examples/filters-general/reshape-table/#overview","text":"This filter will take a vtkTable object and reshape it. This filter essentially treats vtkTable s as 2D matrices and reshapes them using numpy . reshape in a C contiguous manner. Unfortunately, data fields will be renamed arbitrarily because VTK data arrays require a name.","title":"Overview"},{"location":"examples/filters-general/reshape-table/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/reshape-table/#python-example","text":"Take a look at ReshapeTable \u2018s code docs here import numpy as np import vtk from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo.filters import ReshapeTable # Create some input table t0 = vtk . vtkTable () # Populate the tables arrs = [ None , None , None ] n = 400 ncols = 2 nrows = int ( n * len ( arrs ) / ncols ) titles = ( 'Array 0' , 'Array 1' , 'Array 2' ) arrs [ 0 ] = np . random . random ( n ) arrs [ 1 ] = np . random . random ( n ) arrs [ 2 ] = np . random . random ( n ) t0 . AddColumn ( PVGeo . convertArray ( arrs [ 0 ], titles [ 0 ])) t0 . AddColumn ( PVGeo . convertArray ( arrs [ 1 ], titles [ 1 ])) t0 . AddColumn ( PVGeo . convertArray ( arrs [ 2 ], titles [ 2 ])) # Use the filter to reshape the table order = 'F' newtitles = [ 'Title %d ' % i for i in range ( ncols )] output = ReshapeTable ( order = order , ncols = ncols , nrows = nrows , names = newtitles ) . Apply ( t0 ) # Check the output against NumPy wpdi = dsa . WrapDataObject ( output ) tarr = np . zeros (( nrows , ncols )) for i in range ( ncols ): tarr [:, i ] = wpdi . RowData [ i ] arrs = np . array ( arrs ) . T arrs = arrs . flatten () arrs = np . reshape ( arrs , ( nrows , ncols ), order = order ) assert ( tarr . shape == arrs . shape ) assert ( np . allclose ( tarr , arrs ))","title":"Python Example"},{"location":"examples/filters-general/rotate-points/","text":"Info This example will demonstrate how to rotate points in a vtkPolyData object around some origin on the XY plane. Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at RotatePoints \u2018 code docs here import numpy as np from PVGeo import pointsToPolyData from PVGeo.filters import RotatePoints ############## # Create some input points as `vtkPolyData` RTOL = 0.00001 # As high as rotation precision can get x = np . array ([ 0.0 , 1.0 , 0.0 ]) y = np . array ([ 0.0 , 0.0 , 1.0 ]) z = np . array ([ 0.0 , 0.0 , 0.0 ]) x = np . reshape ( x , ( len ( x ), - 1 )) y = np . reshape ( y , ( len ( y ), - 1 )) z = np . reshape ( z , ( len ( z ), - 1 )) pts = np . concatenate (( x , y , z ), axis = 1 ) pdi = pointsToPolyData ( pts ) ############## # Use the filter: rotated = RotatePoints ( angle = 33.3 ) . Apply ( pdi ) print ( rotated )","title":"Rotate Points"},{"location":"examples/filters-general/rotate-points/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/rotate-points/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/rotate-points/#python-example","text":"Take a look at RotatePoints \u2018 code docs here import numpy as np from PVGeo import pointsToPolyData from PVGeo.filters import RotatePoints ############## # Create some input points as `vtkPolyData` RTOL = 0.00001 # As high as rotation precision can get x = np . array ([ 0.0 , 1.0 , 0.0 ]) y = np . array ([ 0.0 , 0.0 , 1.0 ]) z = np . array ([ 0.0 , 0.0 , 0.0 ]) x = np . reshape ( x , ( len ( x ), - 1 )) y = np . reshape ( y , ( len ( y ), - 1 )) z = np . reshape ( z , ( len ( z ), - 1 )) pts = np . concatenate (( x , y , z ), axis = 1 ) pdi = pointsToPolyData ( pts ) ############## # Use the filter: rotated = RotatePoints ( angle = 33.3 ) . Apply ( pdi ) print ( rotated )","title":"Python Example"},{"location":"examples/filters-general/rotation-tool/","text":"Overview \u00b6 The RotationTool is not necessarily an algorithm or plugin but a class full of convenience methods for algorithms that use coordinate rotations. Python Example \u00b6 Take a look at RotationTool \u2018s code docs here","title":"Rotation Tool"},{"location":"examples/filters-general/rotation-tool/#overview","text":"The RotationTool is not necessarily an algorithm or plugin but a class full of convenience methods for algorithms that use coordinate rotations.","title":"Overview"},{"location":"examples/filters-general/rotation-tool/#python-example","text":"Take a look at RotationTool \u2018s code docs here","title":"Python Example"},{"location":"examples/filters-general/slice-through-time/","text":"Info This example will demonstrate how to slice an input data set that will move along an axis as time progresses. Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at SliceThroughTime \u2018s code docs here","title":"Slice Through Time"},{"location":"examples/filters-general/slice-through-time/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/slice-through-time/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/slice-through-time/#python-example","text":"Take a look at SliceThroughTime \u2018s code docs here","title":"Python Example"},{"location":"examples/filters-general/slide-slice-along-points/","text":"Info This example will demonstrate how to slice an input data set and use a slider bar to slide that slice along a series of points Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at SlideSliceAlongPoints \u2018 code docs here","title":"Slide Slice Along Points"},{"location":"examples/filters-general/slide-slice-along-points/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/slide-slice-along-points/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/slide-slice-along-points/#python-example","text":"Take a look at SlideSliceAlongPoints \u2018 code docs here","title":"Python Example"},{"location":"examples/filters-general/split-table-on-array/","text":"Info This example will demonstrate how to separate table data based on the unique values of a given data array into a vtkMultiBlockDataSet Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at SplitTableOnArray \u2018s code docs here","title":"Split Table On Array"},{"location":"examples/filters-general/split-table-on-array/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/split-table-on-array/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/filters-general/split-table-on-array/#python-example","text":"Take a look at SplitTableOnArray \u2018s code docs here","title":"Python Example"},{"location":"examples/filters-general/voxelize-points/","text":"Info This example will demonstrate how to connect a set of points defined on a regular grid to create a vtkUnstructuredGrid which can be used to perform volumetric operations. Overview \u00b6 ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Below is a demonstration of this filter transforming point data (XYZ + attribute) to a gridded data set which is thresholded in the center. Example Python Example \u00b6 Take a look at VoxelizePoints \u2018 code docs here import numpy as np from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo import pointsToPolyData from PVGeo.filters import VoxelizePoints # Make a mesh grid dd = 5 x = y = z = np . arange ( 0 , 100 , dd ) g = np . meshgrid ( x , y , z ) # Convert to XYZ points points = np . vstack ( map ( np . ravel , g )) . T rand = np . random . random ( len ( points )) vtkpoints = pointsToPolyData ( points ) vtkpoints . GetPointData () . AddArray ( PVGeo . convertArray ( rand , 'Random' )) # Use filter v = VoxelizePoints () v . SetInputDataObject ( vtkpoints ) v . SetEstimateGrid ( False ) # Cell size is explicitly set v . SetDeltaX ( 10 ) v . SetDeltaY ( 10 ) v . SetDeltaZ ( 10 ) v . Update () grid = v . GetOutput () wgrd = dsa . WrapDataObject ( grid ) celldata = wgrd . CellData [ 'Random' ] # Checkout output: assert ( grid . GetNumberOfCells () == 8 * 10 ** 3 ) numPts = ( len ( x ) + 2 ) ** 3 assert ( grid . GetNumberOfPoints () == numPts ) assert ( np . allclose ( celldata , rand )) # Now check that we can set the spacing for every cell spac = np . full (( len ( points )), 10.0 ) v . SetDeltas ( spac , spac , spac ) v . Update () grid = v . GetOutput () wgrd = dsa . WrapDataObject ( grid ) celldata = wgrd . CellData [ 'Random' ] assert ( grid . GetNumberOfCells () == 8 * 10 ** 3 ) assert ( grid . GetNumberOfPoints () == numPts ) assert ( np . allclose ( celldata , rand ))","title":"Voxelize Points"},{"location":"examples/filters-general/voxelize-points/#overview","text":"","title":"Overview"},{"location":"examples/filters-general/voxelize-points/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Below is a demonstration of this filter transforming point data (XYZ + attribute) to a gridded data set which is thresholded in the center. Example","title":"ParaView Example"},{"location":"examples/filters-general/voxelize-points/#python-example","text":"Take a look at VoxelizePoints \u2018 code docs here import numpy as np from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo import pointsToPolyData from PVGeo.filters import VoxelizePoints # Make a mesh grid dd = 5 x = y = z = np . arange ( 0 , 100 , dd ) g = np . meshgrid ( x , y , z ) # Convert to XYZ points points = np . vstack ( map ( np . ravel , g )) . T rand = np . random . random ( len ( points )) vtkpoints = pointsToPolyData ( points ) vtkpoints . GetPointData () . AddArray ( PVGeo . convertArray ( rand , 'Random' )) # Use filter v = VoxelizePoints () v . SetInputDataObject ( vtkpoints ) v . SetEstimateGrid ( False ) # Cell size is explicitly set v . SetDeltaX ( 10 ) v . SetDeltaY ( 10 ) v . SetDeltaZ ( 10 ) v . Update () grid = v . GetOutput () wgrd = dsa . WrapDataObject ( grid ) celldata = wgrd . CellData [ 'Random' ] # Checkout output: assert ( grid . GetNumberOfCells () == 8 * 10 ** 3 ) numPts = ( len ( x ) + 2 ) ** 3 assert ( grid . GetNumberOfPoints () == numPts ) assert ( np . allclose ( celldata , rand )) # Now check that we can set the spacing for every cell spac = np . full (( len ( points )), 10.0 ) v . SetDeltas ( spac , spac , spac ) v . Update () grid = v . GetOutput () wgrd = dsa . WrapDataObject ( grid ) celldata = wgrd . CellData [ 'Random' ] assert ( grid . GetNumberOfCells () == 8 * 10 ** 3 ) assert ( grid . GetNumberOfPoints () == numPts ) assert ( np . allclose ( celldata , rand ))","title":"Python Example"},{"location":"examples/grids/esri-grid/","text":"Esri Grid Format \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Take a look at EsriGridReader \u2018s code docs here","title":"ESRI Grid Reader"},{"location":"examples/grids/esri-grid/#esri-grid-format","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Take a look at EsriGridReader \u2018s code docs here","title":"Esri Grid Format"},{"location":"examples/grids/extract-topography/","text":"Info This example will demonstrate how to add a cell data field to an input data set that defines whether that cell should be active. The activity of the cell is determined by whether it is beneath and input topography surface. Overview \u00b6 This filter adds a new cell data field to an input data source defining whether that cell is beneath some input topography surface. Why add a cell data field? We add a cell data field to the input data set as this allows us to use a wide range of input data types. We also add this data array as it will enable users to create model discretizations within ParaView for export to external processing software that need the entire model discretization with an active cells field. ParaView Example \u00b6 PVGeo: Extract Topography Filter from Bane Sullivan on Vimeo . First, lets generate some data on the ParaView pipeline. For this example, we need a topography data set and an input grid data set. Download Data Description Data File: \u2018topo.vtk\u2019 Description: This data file is has a vtkPolyData topography surface we can use. For the grid data set, let\u2019s use one of the Model Building sources: Sources->PVGeo: Model Building->Create Tensor Mesh with the following parameters: Origin: [ 793000 , 9192500 , 2690 ] X Cells: 1000 500 50 * 250 500 1000 Y Cells: 1000 500 55 * 250 500 1000 Z Cells: 30 * 100 . 0 5 * 250 . 0 500 Now we have an input data set that we wish to extract beneath the topography surface shown in the rendering below: The Input Data Apply the Filter \u00b6 Now that you have the topography and a grid data set on the pipeline, let\u2019s go ahead and use the Extract Topography filter: Filters->PVGeo: General Grids->Extract Topography . Be sure to properly select the input data sets in the pop-up dialog like the image below: After selecting the proper inputs, click OK then Apply and find the output data object on the pipeline. Select the output and change the display coloring to the new Active Topography cell field. This will show the cells that are active underneath the topography surface (0 for above surface and 1 for below surface). Now we can threshold this gridded data set to remove parts of the model that are above the topography surface by applying a Threshold filter native to ParaView and chopping out all values below 1. The resulting grid with cells above the topography extracted will look like the rendering below: Example Python Example \u00b6 Take a look at ExtractTopography \u2018s code docs here Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Extract Topography"},{"location":"examples/grids/extract-topography/#overview","text":"This filter adds a new cell data field to an input data source defining whether that cell is beneath some input topography surface. Why add a cell data field? We add a cell data field to the input data set as this allows us to use a wide range of input data types. We also add this data array as it will enable users to create model discretizations within ParaView for export to external processing software that need the entire model discretization with an active cells field.","title":"Overview"},{"location":"examples/grids/extract-topography/#paraview-example","text":"PVGeo: Extract Topography Filter from Bane Sullivan on Vimeo . First, lets generate some data on the ParaView pipeline. For this example, we need a topography data set and an input grid data set. Download Data Description Data File: \u2018topo.vtk\u2019 Description: This data file is has a vtkPolyData topography surface we can use. For the grid data set, let\u2019s use one of the Model Building sources: Sources->PVGeo: Model Building->Create Tensor Mesh with the following parameters: Origin: [ 793000 , 9192500 , 2690 ] X Cells: 1000 500 50 * 250 500 1000 Y Cells: 1000 500 55 * 250 500 1000 Z Cells: 30 * 100 . 0 5 * 250 . 0 500 Now we have an input data set that we wish to extract beneath the topography surface shown in the rendering below: The Input Data","title":"ParaView Example"},{"location":"examples/grids/extract-topography/#apply-the-filter","text":"Now that you have the topography and a grid data set on the pipeline, let\u2019s go ahead and use the Extract Topography filter: Filters->PVGeo: General Grids->Extract Topography . Be sure to properly select the input data sets in the pop-up dialog like the image below: After selecting the proper inputs, click OK then Apply and find the output data object on the pipeline. Select the output and change the display coloring to the new Active Topography cell field. This will show the cells that are active underneath the topography surface (0 for above surface and 1 for below surface). Now we can threshold this gridded data set to remove parts of the model that are above the topography surface by applying a Threshold filter native to ParaView and chopping out all values below 1. The resulting grid with cells above the topography extracted will look like the rendering below: Example","title":"Apply the Filter"},{"location":"examples/grids/extract-topography/#python-example","text":"Take a look at ExtractTopography \u2018s code docs here Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Python Example"},{"location":"examples/grids/raster/","text":"Landsat Rasters \u00b6 This reader uses espatools to read Landsat imagery via an XML metadata file. Espatools is an open-source Python package for simple loading of Landsat imagery as NumPy arrays and we have built an easy to use interface to load any Landsat imagery directly into ParaView with an ability to choose predefined color schemes! Overall, the LandsatReader in PVGeo is meant for direct use in ParaView and we would not recommend using LandsatReader in a standalone Python environment as espatools has a much simpler API. If you\u2019d like to see the code docs for this reader, then: Take a look at LandsatReader \u2018s code docs here . Example \u00b6 Download any Landsat data from USGS\u2019 Earth Explorer and open the XML file adjacent to the data files using PVGeo\u2019s Landsat Reader in ParaView. For this example, we downloaded Landsat 8 imagery over Golden & Boulder, Colorado. This raster set is from Path 34 Row 32 during June 27, 2018. The demonstrated dataset comes as a .tar.gz compressed dataset which contains 10 bands ( .tif files) and a few metadata files ( .txt and .xml files). espatools is built to parse the .xml metadata file to read all of the bands for that dataset and provide a convenient and intuitive means of accessing that metadata along side the raw data in a Python environment. Using PVGeo in ParaView, you can select File->Open\u2026 and select the .xml metadata file and PVGeo will know to use the LandsatReader to read all of the bands. Select your bands \u00b6 Go ahead and load up all the data! If you only want a few bands, then select them from the checklist like the image below: Select your bands using the checkboxes. We usually load all of the bands but if you want to conserve memory and have faster file reads, definitely only select the bands you desire. After loading you can select any of the bands as data arrays to display in the Render View. Here is an example of Band 3 from our sample dataset: Use RGB Color Schemes \u00b6 If your raster has enough bands for RGB data, then select the a Color Scheme from the drop down menu. This will add a new RGB data array for your raster set. To see the RGB values in the Render View, turn off Map Scalars in the properties to display a true color image. Warning Color Scheme uses predefined color schemes for the raster set\u2019s satellite which espatools manages on the backend. You may need to load all data arrays/bands for this to work. We recommend selecting the bands you need then using PVGeo\u2019s ArraysToRGBA filter. Select a Color Scheme : Be sure to turn off Map Scalars to see the RGB values:","title":"Landsat Rasters"},{"location":"examples/grids/raster/#landsat-rasters","text":"This reader uses espatools to read Landsat imagery via an XML metadata file. Espatools is an open-source Python package for simple loading of Landsat imagery as NumPy arrays and we have built an easy to use interface to load any Landsat imagery directly into ParaView with an ability to choose predefined color schemes! Overall, the LandsatReader in PVGeo is meant for direct use in ParaView and we would not recommend using LandsatReader in a standalone Python environment as espatools has a much simpler API. If you\u2019d like to see the code docs for this reader, then: Take a look at LandsatReader \u2018s code docs here .","title":"Landsat Rasters"},{"location":"examples/grids/raster/#example","text":"Download any Landsat data from USGS\u2019 Earth Explorer and open the XML file adjacent to the data files using PVGeo\u2019s Landsat Reader in ParaView. For this example, we downloaded Landsat 8 imagery over Golden & Boulder, Colorado. This raster set is from Path 34 Row 32 during June 27, 2018. The demonstrated dataset comes as a .tar.gz compressed dataset which contains 10 bands ( .tif files) and a few metadata files ( .txt and .xml files). espatools is built to parse the .xml metadata file to read all of the bands for that dataset and provide a convenient and intuitive means of accessing that metadata along side the raw data in a Python environment. Using PVGeo in ParaView, you can select File->Open\u2026 and select the .xml metadata file and PVGeo will know to use the LandsatReader to read all of the bands.","title":"Example"},{"location":"examples/grids/raster/#select-your-bands","text":"Go ahead and load up all the data! If you only want a few bands, then select them from the checklist like the image below: Select your bands using the checkboxes. We usually load all of the bands but if you want to conserve memory and have faster file reads, definitely only select the bands you desire. After loading you can select any of the bands as data arrays to display in the Render View. Here is an example of Band 3 from our sample dataset:","title":"Select your bands"},{"location":"examples/grids/raster/#use-rgb-color-schemes","text":"If your raster has enough bands for RGB data, then select the a Color Scheme from the drop down menu. This will add a new RGB data array for your raster set. To see the RGB values in the Render View, turn off Map Scalars in the properties to display a true color image. Warning Color Scheme uses predefined color schemes for the raster set\u2019s satellite which espatools manages on the backend. You may need to load all data arrays/bands for this to work. We recommend selecting the bands you need then using PVGeo\u2019s ArraysToRGBA filter. Select a Color Scheme : Be sure to turn off Map Scalars to see the RGB values:","title":"Use RGB Color Schemes"},{"location":"examples/grids/reverse-grid-axii/","text":"Info This example will demonstrate how to \u2026 Overview \u00b6 This filter will flip ImageData on any of the three cartesian axes. A checkbox is provided for each axis on which you may desire to flip the data. ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at ReverseImageDataAxii \u2018s code docs here import numpy as np import vtk from vtk.util import numpy_support as nps from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo.grids import ReverseImageDataAxii ############################### # Create input vtkImageData: nx , ny , nz = 10 , 11 , 12 arr = np . random . random (( nz , ny , nx )) arrCells = np . random . random (( nz - 1 , ny - 1 , nx - 1 )) # Note fortran ordering image = vtk . vtkImageData () image . SetDimensions ( nx , ny , nz ) image . SetSpacing ( 2 , 2 , 2 ) image . SetOrigin ( 0 , 0 , 0 ) data = nps . numpy_to_vtk ( num_array = arr . flatten (), deep = True ) data . SetName ( 'Data' ) cellData = nps . numpy_to_vtk ( num_array = arrCells . flatten (), deep = True ) cellData . SetName ( 'CellData' ) image . GetPointData () . AddArray ( data ) image . GetCellData () . AddArray ( cellData ) ############################### # Now perfrom the reverse for only X: ido = ReverseImageDataAxii ( axes = [ 1 , 0 , 0 ]) . Apply ( image ) # Now check the output assert ( ido . GetNumberOfPoints () == len ( arr . flatten ())) # Check that x-axis was reversed wido = dsa . WrapDataObject ( ido ) testPointData = wido . PointData [ 'Data' ] testCellData = wido . CellData [ 'CellData' ] assert ( np . allclose ( testPointData , np . flip ( arr , axis = 2 ) . flatten ())) assert ( np . allclose ( testCellData , np . flip ( arrCells , axis = 2 ) . flatten ()))","title":"Flip Grid Axii"},{"location":"examples/grids/reverse-grid-axii/#overview","text":"This filter will flip ImageData on any of the three cartesian axes. A checkbox is provided for each axis on which you may desire to flip the data.","title":"Overview"},{"location":"examples/grids/reverse-grid-axii/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/grids/reverse-grid-axii/#python-example","text":"Take a look at ReverseImageDataAxii \u2018s code docs here import numpy as np import vtk from vtk.util import numpy_support as nps from vtk.numpy_interface import dataset_adapter as dsa import PVGeo from PVGeo.grids import ReverseImageDataAxii ############################### # Create input vtkImageData: nx , ny , nz = 10 , 11 , 12 arr = np . random . random (( nz , ny , nx )) arrCells = np . random . random (( nz - 1 , ny - 1 , nx - 1 )) # Note fortran ordering image = vtk . vtkImageData () image . SetDimensions ( nx , ny , nz ) image . SetSpacing ( 2 , 2 , 2 ) image . SetOrigin ( 0 , 0 , 0 ) data = nps . numpy_to_vtk ( num_array = arr . flatten (), deep = True ) data . SetName ( 'Data' ) cellData = nps . numpy_to_vtk ( num_array = arrCells . flatten (), deep = True ) cellData . SetName ( 'CellData' ) image . GetPointData () . AddArray ( data ) image . GetCellData () . AddArray ( cellData ) ############################### # Now perfrom the reverse for only X: ido = ReverseImageDataAxii ( axes = [ 1 , 0 , 0 ]) . Apply ( image ) # Now check the output assert ( ido . GetNumberOfPoints () == len ( arr . flatten ())) # Check that x-axis was reversed wido = dsa . WrapDataObject ( ido ) testPointData = wido . PointData [ 'Data' ] testCellData = wido . CellData [ 'CellData' ] assert ( np . allclose ( testPointData , np . flip ( arr , axis = 2 ) . flatten ())) assert ( np . allclose ( testCellData , np . flip ( arrCells , axis = 2 ) . flatten ()))","title":"Python Example"},{"location":"examples/grids/surfer-grid/","text":"Surfer Grid Format \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Reader \u00b6 Take a look at SurferGridReader \u2018s code docs here Writer \u00b6 Take a look at WriteImageDataToSurfer \u2018s code docs here","title":"Surfer Grids"},{"location":"examples/grids/surfer-grid/#surfer-grid-format","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Surfer Grid Format"},{"location":"examples/grids/surfer-grid/#reader","text":"Take a look at SurferGridReader \u2018s code docs here","title":"Reader"},{"location":"examples/grids/surfer-grid/#writer","text":"Take a look at WriteImageDataToSurfer \u2018s code docs here","title":"Writer"},{"location":"examples/grids/table-to-uniform-grid/","text":"Table to Time Grid \u00b6 Overview \u00b6 This filter takes a vtkTable object with columns that represent data to be translated (reshaped) into a 3D grid (2D also works, just set the third dimensions extent to 1). The grid will be a n1 by n2 by n3 vtkImageData structure and an origin (south-west bottom corner) can be set at any xyz point. Each column of the vtkTable will represent a data attribute of the vtkImageData formed (essentially a uniform mesh). ParaView Example \u00b6 Say we have some data in 1D format or a series of 1D data sets, like a vtkTable where we have columns of data which we know can be restructured into a 2D or 3D volume. One great example is the the table made in the example for using the Read Binary Packed Data reader. Follow the instructions to read in that data to a vtkTable . Once you have sample data in a vtkTable , we can apply a the \u2018Table to Uniform Grid\u2019 Filter and specify the shape of our volumetric data (for 2D data like this example, specify n1 and n2 accordingly and leave n3 as 1). The script provided in the example will output the extent, origin, and spacing parameters for you to use (best to copy/paste from that output into the parameter fields). This example will produce the 2D grid depicted on the Read Binary Packed Data page (that image adds the \u2018Warp by Scalar\u2019 filter). Another example is to use one of the data files from this website and load it in using the GSLIB File to Table reader. These files are in the SGeMS file format but can also be read by the GSLIB file reader. Through loading this data into a table and then applying a Table to Time Grid Filter, we are effectively mimicking what the [SGeMS Grid][reader-grid] reader is doing behind the scenes. These SGeMS files make great example because they outline how we can transfer any data with any number of data arrays to a uniform grid (each data array in the input table will represent a different attribute of the space made up by the vtkImageData grid). The GSLIB reader will print out the dimensions of the grid to the Output Messages console (to see this, select View->Output Messages). Use those dimensions for the n1, n2, and n3 parameters. Play around with the other parameters to get a feel for how this filter behaves. Down the Pipeline \u00b6 Translate Origin of Grid Reverse Grid Axii Normalize Array Contour Threshold Python Example \u00b6 Take a look at TableToTimeGrid \u2018s code docs here import numpy as np import vtk import PVGeo from PVGeo.grids import TableToTimeGrid ############################### # Create some input tables table = vtk . vtkTable () # Populate the tables arrs = [ None , None , None ] n = 400 titles = ( 'Array 0' , 'Array 1' , 'Array 2' ) arrs [ 0 ] = np . random . random ( n ) arrs [ 1 ] = np . random . random ( n ) arrs [ 2 ] = np . random . random ( n ) table . AddColumn ( PVGeo . convertArray ( arrs [ 0 ], titles [ 0 ])) table . AddColumn ( PVGeo . convertArray ( arrs [ 1 ], titles [ 1 ])) table . AddColumn ( PVGeo . convertArray ( arrs [ 2 ], titles [ 2 ])) ############################### # Use filter f = TableToTimeGrid () f . SetExtent ( 20 , 2 , 10 , 1 ) f . SetSpacing ( 5 , 5 , 5 ) f . SetOrigin ( 3.3 , 6.0 , 7 ) ido = f . Apply ( table )","title":"Table to Uniform Grid"},{"location":"examples/grids/table-to-uniform-grid/#table-to-time-grid","text":"","title":"Table to Time Grid"},{"location":"examples/grids/table-to-uniform-grid/#overview","text":"This filter takes a vtkTable object with columns that represent data to be translated (reshaped) into a 3D grid (2D also works, just set the third dimensions extent to 1). The grid will be a n1 by n2 by n3 vtkImageData structure and an origin (south-west bottom corner) can be set at any xyz point. Each column of the vtkTable will represent a data attribute of the vtkImageData formed (essentially a uniform mesh).","title":"Overview"},{"location":"examples/grids/table-to-uniform-grid/#paraview-example","text":"Say we have some data in 1D format or a series of 1D data sets, like a vtkTable where we have columns of data which we know can be restructured into a 2D or 3D volume. One great example is the the table made in the example for using the Read Binary Packed Data reader. Follow the instructions to read in that data to a vtkTable . Once you have sample data in a vtkTable , we can apply a the \u2018Table to Uniform Grid\u2019 Filter and specify the shape of our volumetric data (for 2D data like this example, specify n1 and n2 accordingly and leave n3 as 1). The script provided in the example will output the extent, origin, and spacing parameters for you to use (best to copy/paste from that output into the parameter fields). This example will produce the 2D grid depicted on the Read Binary Packed Data page (that image adds the \u2018Warp by Scalar\u2019 filter). Another example is to use one of the data files from this website and load it in using the GSLIB File to Table reader. These files are in the SGeMS file format but can also be read by the GSLIB file reader. Through loading this data into a table and then applying a Table to Time Grid Filter, we are effectively mimicking what the [SGeMS Grid][reader-grid] reader is doing behind the scenes. These SGeMS files make great example because they outline how we can transfer any data with any number of data arrays to a uniform grid (each data array in the input table will represent a different attribute of the space made up by the vtkImageData grid). The GSLIB reader will print out the dimensions of the grid to the Output Messages console (to see this, select View->Output Messages). Use those dimensions for the n1, n2, and n3 parameters. Play around with the other parameters to get a feel for how this filter behaves.","title":"ParaView Example"},{"location":"examples/grids/table-to-uniform-grid/#down-the-pipeline","text":"Translate Origin of Grid Reverse Grid Axii Normalize Array Contour Threshold","title":"Down the Pipeline"},{"location":"examples/grids/table-to-uniform-grid/#python-example","text":"Take a look at TableToTimeGrid \u2018s code docs here import numpy as np import vtk import PVGeo from PVGeo.grids import TableToTimeGrid ############################### # Create some input tables table = vtk . vtkTable () # Populate the tables arrs = [ None , None , None ] n = 400 titles = ( 'Array 0' , 'Array 1' , 'Array 2' ) arrs [ 0 ] = np . random . random ( n ) arrs [ 1 ] = np . random . random ( n ) arrs [ 2 ] = np . random . random ( n ) table . AddColumn ( PVGeo . convertArray ( arrs [ 0 ], titles [ 0 ])) table . AddColumn ( PVGeo . convertArray ( arrs [ 1 ], titles [ 1 ])) table . AddColumn ( PVGeo . convertArray ( arrs [ 2 ], titles [ 2 ])) ############################### # Use filter f = TableToTimeGrid () f . SetExtent ( 20 , 2 , 10 , 1 ) f . SetSpacing ( 5 , 5 , 5 ) f . SetOrigin ( 3.3 , 6.0 , 7 ) ido = f . Apply ( table )","title":"Python Example"},{"location":"examples/grids/translate-origin-of-grid/","text":"Info This example will demonstrate how to \u2026 Overview \u00b6 This filter will translate the origin of vtkImageData to any specified Corner of the data set assuming it is currently in the South West Bottom Corner (will not work if Corner was moved prior). ParaView Example \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Python Example \u00b6 Take a look at TranslateGridOrigin \u2018s code docs here import numpy as np import vtk import PVGeo from PVGeo.grids import TranslateGridOrigin ############################### # Create some input tables idi = vtk . vtkImageData () idi . SetDimensions ( 20 , 2 , 10 ) idi . SetSpacing ( 1 , 1 , 1 ) idi . SetOrigin ( 100 , 100 , 100 ) # Populate the tables n = 400 title = 'Array 0' arr = np . random . random ( n ) idi . GetPointData () . AddArray ( PVGeo . convertArray ( arr , title )) ############################### # Use the filter ido = TranslateGridOrigin ( corner = 1 ) . Apply ( idi ) # Checj the result ox , oy , oz = ido . GetOrigin () assert ( ox == 100 - 19 ) assert ( oy == 100 ) assert ( oz == 100 )","title":"Translate Origin of Grid"},{"location":"examples/grids/translate-origin-of-grid/#overview","text":"This filter will translate the origin of vtkImageData to any specified Corner of the data set assuming it is currently in the South West Bottom Corner (will not work if Corner was moved prior).","title":"Overview"},{"location":"examples/grids/translate-origin-of-grid/#paraview-example","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"ParaView Example"},{"location":"examples/grids/translate-origin-of-grid/#python-example","text":"Take a look at TranslateGridOrigin \u2018s code docs here import numpy as np import vtk import PVGeo from PVGeo.grids import TranslateGridOrigin ############################### # Create some input tables idi = vtk . vtkImageData () idi . SetDimensions ( 20 , 2 , 10 ) idi . SetSpacing ( 1 , 1 , 1 ) idi . SetOrigin ( 100 , 100 , 100 ) # Populate the tables n = 400 title = 'Array 0' arr = np . random . random ( n ) idi . GetPointData () . AddArray ( PVGeo . convertArray ( arr , title )) ############################### # Use the filter ido = TranslateGridOrigin ( corner = 1 ) . Apply ( idi ) # Checj the result ox , oy , oz = ido . GetOrigin () assert ( ox == 100 - 19 ) assert ( oy == 100 ) assert ( oz == 100 )","title":"Python Example"},{"location":"examples/grids/write-cell-centers/","text":"Write Cell Centers \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Writer \u00b6 Take a look at WriteCellCenterData \u2018s code docs here","title":"Write Cell Centers"},{"location":"examples/grids/write-cell-centers/#write-cell-centers","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Write Cell Centers"},{"location":"examples/grids/write-cell-centers/#writer","text":"Take a look at WriteCellCenterData \u2018s code docs here","title":"Writer"},{"location":"examples/gslib/gslib/","text":"GSLib Tables \u00b6 About this Format \u00b6 The GSLIB file format has headers lines followed by the data as a space delimited ASCI file (this filter is set up to allow you to choose any single character delimiter: default is a space). The first header line contains the title or necessary information and will be printed to the console. This line may have the dimensions for a grid to be made of the data. The second line is the number (n) of columns of data. The next n lines are the variable names for the data in each column. You are allowed up to ten characters for the variable name. The data follow with a space between each field (column). Reader \u00b6 The output of this reader is a vtkTable of the input data. The table will have all the same columns as the input file with the column/data names set to their respective names from the input file. Take a look at GSLibReader \u2018s code docs here The GSLIB File Format Check out this site and this site for more information on the specifics of the file format. The general format is as follows: Header numberOfColumns Column_1_name Column_2_name Column_3_name ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ... An example file might look something like this: Fun data set ! 3 Variable1 Variable2 Variable3 0 . 908793985844 - 0 . 141859993339 0 . 76693302393 0 . 909209012985 0 . 0264630001038 0 . 935671985149 0 . 908389985561 - 0 . 0224980004132 0 . 885891973972 0 . 906355023384 - 0 . 0762720033526 0 . 83008402586 0 . 895779013634 0 . 0125150000677 0 . 908294022083 0 . 876645028591 - 0 . 0550080016255 0 . 821636974812 0 . 856096029282 0 . 0719339996576 0 . 928031027317 ... Down the Pipeline \u00b6 Table to Uniform Grid Reshape Table Table to Points Table to Structured Grid Normalize Array Writer \u00b6 The GSLib format writer takes vtkTable s as an input and saves them to the GSLib file format. Take a look at WriteTableToGSLib \u2018s code docs here","title":"GSLib Tables"},{"location":"examples/gslib/gslib/#gslib-tables","text":"","title":"GSLib Tables"},{"location":"examples/gslib/gslib/#about-this-format","text":"The GSLIB file format has headers lines followed by the data as a space delimited ASCI file (this filter is set up to allow you to choose any single character delimiter: default is a space). The first header line contains the title or necessary information and will be printed to the console. This line may have the dimensions for a grid to be made of the data. The second line is the number (n) of columns of data. The next n lines are the variable names for the data in each column. You are allowed up to ten characters for the variable name. The data follow with a space between each field (column).","title":"About this Format"},{"location":"examples/gslib/gslib/#reader","text":"The output of this reader is a vtkTable of the input data. The table will have all the same columns as the input file with the column/data names set to their respective names from the input file. Take a look at GSLibReader \u2018s code docs here The GSLIB File Format Check out this site and this site for more information on the specifics of the file format. The general format is as follows: Header numberOfColumns Column_1_name Column_2_name Column_3_name ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ### . ### ... An example file might look something like this: Fun data set ! 3 Variable1 Variable2 Variable3 0 . 908793985844 - 0 . 141859993339 0 . 76693302393 0 . 909209012985 0 . 0264630001038 0 . 935671985149 0 . 908389985561 - 0 . 0224980004132 0 . 885891973972 0 . 906355023384 - 0 . 0762720033526 0 . 83008402586 0 . 895779013634 0 . 0125150000677 0 . 908294022083 0 . 876645028591 - 0 . 0550080016255 0 . 821636974812 0 . 856096029282 0 . 0719339996576 0 . 928031027317 ...","title":"Reader"},{"location":"examples/gslib/gslib/#down-the-pipeline","text":"Table to Uniform Grid Reshape Table Table to Points Table to Structured Grid Normalize Array","title":"Down the Pipeline"},{"location":"examples/gslib/gslib/#writer","text":"The GSLib format writer takes vtkTable s as an input and saves them to the GSLib file format. Take a look at WriteTableToGSLib \u2018s code docs here","title":"Writer"},{"location":"examples/gslib/sgems-grid/","text":"Read SGeMS Grid \u00b6 The Stanford Geostatistical Modeling Software (SGeMS) ASCII format is much like the GSLIB ) file format. The reader we have developed for this format assumes the data to be defined on a regularly spaced grid and that the first line of the file will specify the dimensions of that grid. The SGeMS File Format The general format is the same as the GSLIB format except that the header line has three integer values to specify the extent of the gridded data. n1 n2 n3 numberOfColumns Col1_name Col2_name Col3_name dataCol1 dataCol2 dataCol3 dataCol1 dataCol2 dataCol3 dataCol1 dataCol2 dataCol3 dataCol1 dataCol2 dataCol3 dataCol1 dataCol2 dataCol3 ... An example file might look something like this, where we have a 400 by 150 by 40 (x by y by z) grid with uniform spacing along each axis with three data arrays: 400 150 40 3 Variable1 Variable2 Variable3 0 . 908793985844 - 0 . 141859993339 0 . 76693302393 0 . 909209012985 0 . 0264630001038 0 . 935671985149 0 . 908389985561 - 0 . 0224980004132 0 . 885891973972 0 . 906355023384 - 0 . 0762720033526 0 . 83008402586 0 . 895779013634 0 . 0125150000677 0 . 908294022083 0 . 876645028591 - 0 . 0550080016255 0 . 821636974812 0 . 856096029282 0 . 0719339996576 0 . 928031027317 ... Reader \u00b6 The output of this file reader is a vtkImageData object which is essentially a regularly spaced grid with varying dimensionality along each axis. The reader will only work if the format of the file strictly follows what is below. If your SGeMS file does not strictly follow the uniform grid format below then we recommend use the GSLIB file reader. ParaView Example \u00b6 PVGeo: SGeMS Grid Reader from Bane Sullivan on Vimeo . For example files to use with this reader, download any of the 2D or 3D files from this website and load them into ParaView using the \u2018Read SGeMS File to Uniform Grid\u2019 file reader. A 2D or 3D block of data should automatically be built and visualized. Here is the Walker Lake Exhaustive DEM Categorized with a categorized color scale and the surface warped by categorization to give it an interesting 3D representation: and here is the FLUVSIM object-based model with a categorized color scale (bounding surfaces are set to be transparent): Down the Pipeline \u00b6 Translate Origin of Grid Reverse Grid Axii Normalize Array Contour Threshold Python Example \u00b6 Take a look at SGeMSGridReader \u2018s code docs here For this example, please download one of the above data files to use or use your own SGeMS grid file and be sure to change the filename from PVGeo.gslib import SGeMSGridReader ################################## # Get the file name filename = 'topexample.sgems' ################################## # Now use the filter: grid = SGeMSGridReader () . Apply ( filename ) # Or you can set the grid options: grid = SGeMSGridReader ( origin = ( 100.0 , 10.0 , 345.0 ), spacing = ( 10.0 , 10.0 , 10.0 )) . Apply ( filename ) # Or you could directly edit the output vtkImageData object grid = SGeMSGridReader () . Apply ( filename ) grid . SetOrigin ( 100.0 , 10.0 , 345.0 ) grid . SetSpacing ( 10.0 , 10.0 , 10.0 ) Note you could use a time series of data files: from PVGeo.gslib import SGeMSGridReader ################################## # Get the file name filenames = [ 'data %d .sgems' for i in range ( 100 )] ################################## # Now use the filter: reader = SGeMSGridReader () grid = reader . Apply ( filenames ) # NOTE: the default output is at time step 0. To request a time step: reader . UpdateTimeStep ( 25 ) # the grid object is now updated to the 25th time step Writer \u00b6 The SGeMS Grid writer takes vtkImageData objects as an input and saves them to the SGeMS Grid file format. Take a look at WriteImageDataToSGeMS \u2018s code docs here","title":"SGeMS Grids"},{"location":"examples/gslib/sgems-grid/#read-sgems-grid","text":"The Stanford Geostatistical Modeling Software (SGeMS) ASCII format is much like the GSLIB ) file format. The reader we have developed for this format assumes the data to be defined on a regularly spaced grid and that the first line of the file will specify the dimensions of that grid. The SGeMS File Format The general format is the same as the GSLIB format except that the header line has three integer values to specify the extent of the gridded data. n1 n2 n3 numberOfColumns Col1_name Col2_name Col3_name dataCol1 dataCol2 dataCol3 dataCol1 dataCol2 dataCol3 dataCol1 dataCol2 dataCol3 dataCol1 dataCol2 dataCol3 dataCol1 dataCol2 dataCol3 ... An example file might look something like this, where we have a 400 by 150 by 40 (x by y by z) grid with uniform spacing along each axis with three data arrays: 400 150 40 3 Variable1 Variable2 Variable3 0 . 908793985844 - 0 . 141859993339 0 . 76693302393 0 . 909209012985 0 . 0264630001038 0 . 935671985149 0 . 908389985561 - 0 . 0224980004132 0 . 885891973972 0 . 906355023384 - 0 . 0762720033526 0 . 83008402586 0 . 895779013634 0 . 0125150000677 0 . 908294022083 0 . 876645028591 - 0 . 0550080016255 0 . 821636974812 0 . 856096029282 0 . 0719339996576 0 . 928031027317 ...","title":"Read SGeMS Grid"},{"location":"examples/gslib/sgems-grid/#reader","text":"The output of this file reader is a vtkImageData object which is essentially a regularly spaced grid with varying dimensionality along each axis. The reader will only work if the format of the file strictly follows what is below. If your SGeMS file does not strictly follow the uniform grid format below then we recommend use the GSLIB file reader.","title":"Reader"},{"location":"examples/gslib/sgems-grid/#paraview-example","text":"PVGeo: SGeMS Grid Reader from Bane Sullivan on Vimeo . For example files to use with this reader, download any of the 2D or 3D files from this website and load them into ParaView using the \u2018Read SGeMS File to Uniform Grid\u2019 file reader. A 2D or 3D block of data should automatically be built and visualized. Here is the Walker Lake Exhaustive DEM Categorized with a categorized color scale and the surface warped by categorization to give it an interesting 3D representation: and here is the FLUVSIM object-based model with a categorized color scale (bounding surfaces are set to be transparent):","title":"ParaView Example"},{"location":"examples/gslib/sgems-grid/#down-the-pipeline","text":"Translate Origin of Grid Reverse Grid Axii Normalize Array Contour Threshold","title":"Down the Pipeline"},{"location":"examples/gslib/sgems-grid/#python-example","text":"Take a look at SGeMSGridReader \u2018s code docs here For this example, please download one of the above data files to use or use your own SGeMS grid file and be sure to change the filename from PVGeo.gslib import SGeMSGridReader ################################## # Get the file name filename = 'topexample.sgems' ################################## # Now use the filter: grid = SGeMSGridReader () . Apply ( filename ) # Or you can set the grid options: grid = SGeMSGridReader ( origin = ( 100.0 , 10.0 , 345.0 ), spacing = ( 10.0 , 10.0 , 10.0 )) . Apply ( filename ) # Or you could directly edit the output vtkImageData object grid = SGeMSGridReader () . Apply ( filename ) grid . SetOrigin ( 100.0 , 10.0 , 345.0 ) grid . SetSpacing ( 10.0 , 10.0 , 10.0 ) Note you could use a time series of data files: from PVGeo.gslib import SGeMSGridReader ################################## # Get the file name filenames = [ 'data %d .sgems' for i in range ( 100 )] ################################## # Now use the filter: reader = SGeMSGridReader () grid = reader . Apply ( filenames ) # NOTE: the default output is at time step 0. To request a time step: reader . UpdateTimeStep ( 25 ) # the grid object is now updated to the 25th time step","title":"Python Example"},{"location":"examples/gslib/sgems-grid/#writer","text":"The SGeMS Grid writer takes vtkImageData objects as an input and saves them to the SGeMS Grid file format. Take a look at WriteImageDataToSGeMS \u2018s code docs here","title":"Writer"},{"location":"examples/interface/points-to-polydata/","text":"Points to PolyData \u00b6 Info This example will demonstrate how to use the pointsToPolyData function to convert a 2D NumPy array of points (n by 3) into vtkPolyData containing those points. Overview \u00b6 This function is a convenience method to convert a NumPy array of points into a vtkPolyData object with the points and cell connectivity properly built. ParaView Example \u00b6 Since this is a convenience function and not as algorithm/plugin, there is not a full ParaView example. However, we use the method in Programmable Sources quite often in the ParaView examples of other algorithms to generate an input data set of points. Check out the following if you\u2019re interested: Voxelize Points Add Cell Connectivity to Points Points to Tube Python Example \u00b6 Take a look at pointsToPolyData \u2018s code docs here import numpy as np from PVGeo import pointsToPolyData # NumPy array of points for input points = np . random . random (( 100 , 3 )) vtkPoints = pointsToPolyData ( points ) print ( vtkPoints )","title":"Points to PolyData"},{"location":"examples/interface/points-to-polydata/#points-to-polydata","text":"Info This example will demonstrate how to use the pointsToPolyData function to convert a 2D NumPy array of points (n by 3) into vtkPolyData containing those points.","title":"Points to PolyData"},{"location":"examples/interface/points-to-polydata/#overview","text":"This function is a convenience method to convert a NumPy array of points into a vtkPolyData object with the points and cell connectivity properly built.","title":"Overview"},{"location":"examples/interface/points-to-polydata/#paraview-example","text":"Since this is a convenience function and not as algorithm/plugin, there is not a full ParaView example. However, we use the method in Programmable Sources quite often in the ParaView examples of other algorithms to generate an input data set of points. Check out the following if you\u2019re interested: Voxelize Points Add Cell Connectivity to Points Points to Tube","title":"ParaView Example"},{"location":"examples/interface/points-to-polydata/#python-example","text":"Take a look at pointsToPolyData \u2018s code docs here import numpy as np from PVGeo import pointsToPolyData # NumPy array of points for input points = np . random . random (( 100 , 3 )) vtkPoints = pointsToPolyData ( points ) print ( vtkPoints )","title":"Python Example"},{"location":"examples/model-building/create-earth-source/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Create Earth Source"},{"location":"examples/model-building/create-rectilinear-grid/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page PVGeo: Tensor Mesh Source from Bane Sullivan on Vimeo . Take a look at CreateTensorMesh \u2018s code docs here Take a look at CreateEvenRectilinearGrid \u2018s code docs here","title":"Create Rectilinear Grid"},{"location":"examples/model-building/create-uniform-grid/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Take a look at CreateUniformGrid \u2018s code docs here","title":"Create Uniform Grid"},{"location":"examples/readers-general/binary-packed-data/","text":"Purpose This file format reader provides a tool read a common data type throughout many software packages like Madagascar or SEPlib which save an array of data ( float , double , or int ) in their binary form to a file. This array can be read into a vtkDataArray which we can then work with to reshape into a grid or use for any other reason on the ParaView pipeline. About this Reader \u00b6 This filter reads in float , double , or int data that is packed into a binary file format. It will treat the data as one long array and make a vtkTable with one column of that data. You can also chose the endianness which defaults to the native system endianness. Use the \u2018Table to Uniform Grid\u2019 or the \u2018Reshape Table\u2019 filters to give more meaning to the data. We chose to use a vtkTable object as the output of this reader because it gives us more flexibility in the filters we can apply to this data down the pipeline and keeps thing simple when using filters in this repository. The default for the data variable name is the base name of the file, however you may want something less verbose or more specific which can be specified in the Data Name attribute field. Down the Pipeline \u00b6 Table to Uniform Grid Reshape Table Table to Points Table to Structured Grid Normalize Array Example Use \u00b6 For an example of how to use this reader, lets make our own test file of packed floats in binary format. Run this script outside of ParaView to create a test file. It will compute a ripple function and write out all the Z data as packed floats. Code to create an input file import struct import numpy as np # The 2D space we are working with step = np . pi / 64. x = y = np . arange ( - np . pi , np . pi + step , step ) X , Y = np . meshgrid ( x , y ) # A cool looking ripple function def f ( x , y ): return np . sin (( x ** 2 + y ** 2 )) # Compute the values of the ripple function in our space Z = np . zeros ( np . shape ( X ), dtype = np . float32 ) for i in range ( len ( x )): for j in range ( len ( y )): Z [ i , j ] = f ( X [ i , j ], Y [ i , j ]) # Parameters for a 'Table to Uniform Grid' filter print ( \"Shape of grid (n1,n2,n3): \" , np . shape ( Z )) print ( \"Spacing for all axii: \" , step ) print ( \"Origin (x,y,z): \" , ( np . min ( x ), np . min ( y ), 0.0 )) #---- Export Data ----# # NOTE: Copy and paste the code below for your needs # Flatten the matrix in C-Contiguous manner Z = Z . flatten () ### Choose floats or doubles ## # Pack as FLOATs in NATIVE `@` endianness: data = struct . pack ( '@' + str ( len ( Z )) + 'f' , * Z ) # Or pack as DOUBLEs: # (be sure to enable the 'Double Values' checkbox # on the reader when loading into ParaView) #data = struct.pack('@'+str(len(Z))+'d',*Z) # Open file to write binary data f = open ( '~/test_file.bin' , 'wb' ) # Write out the packed data in binary format f . write ( data ) # Close the file f . close () Now select \u2018File->Open\u2026\u2019 within ParaView and choose test_file . bin wherever you saved it. This reader will unpack the floats and load them into a table. You can now use this data in many ways. For example, apply a \u2018Table to Uniform Grid\u2019 filter (from this repository) and set the filter parameters to the information in the print out from when you ran the script above. Once you have vtkImageData made of the data, you can apply a \u2018Warp by Scalar\u2019 filter for a fun visualization effect to see 3D ripples like the example below!","title":"Binary Packed Data"},{"location":"examples/readers-general/binary-packed-data/#about-this-reader","text":"This filter reads in float , double , or int data that is packed into a binary file format. It will treat the data as one long array and make a vtkTable with one column of that data. You can also chose the endianness which defaults to the native system endianness. Use the \u2018Table to Uniform Grid\u2019 or the \u2018Reshape Table\u2019 filters to give more meaning to the data. We chose to use a vtkTable object as the output of this reader because it gives us more flexibility in the filters we can apply to this data down the pipeline and keeps thing simple when using filters in this repository. The default for the data variable name is the base name of the file, however you may want something less verbose or more specific which can be specified in the Data Name attribute field.","title":"About this Reader"},{"location":"examples/readers-general/binary-packed-data/#down-the-pipeline","text":"Table to Uniform Grid Reshape Table Table to Points Table to Structured Grid Normalize Array","title":"Down the Pipeline"},{"location":"examples/readers-general/binary-packed-data/#example-use","text":"For an example of how to use this reader, lets make our own test file of packed floats in binary format. Run this script outside of ParaView to create a test file. It will compute a ripple function and write out all the Z data as packed floats. Code to create an input file import struct import numpy as np # The 2D space we are working with step = np . pi / 64. x = y = np . arange ( - np . pi , np . pi + step , step ) X , Y = np . meshgrid ( x , y ) # A cool looking ripple function def f ( x , y ): return np . sin (( x ** 2 + y ** 2 )) # Compute the values of the ripple function in our space Z = np . zeros ( np . shape ( X ), dtype = np . float32 ) for i in range ( len ( x )): for j in range ( len ( y )): Z [ i , j ] = f ( X [ i , j ], Y [ i , j ]) # Parameters for a 'Table to Uniform Grid' filter print ( \"Shape of grid (n1,n2,n3): \" , np . shape ( Z )) print ( \"Spacing for all axii: \" , step ) print ( \"Origin (x,y,z): \" , ( np . min ( x ), np . min ( y ), 0.0 )) #---- Export Data ----# # NOTE: Copy and paste the code below for your needs # Flatten the matrix in C-Contiguous manner Z = Z . flatten () ### Choose floats or doubles ## # Pack as FLOATs in NATIVE `@` endianness: data = struct . pack ( '@' + str ( len ( Z )) + 'f' , * Z ) # Or pack as DOUBLEs: # (be sure to enable the 'Double Values' checkbox # on the reader when loading into ParaView) #data = struct.pack('@'+str(len(Z))+'d',*Z) # Open file to write binary data f = open ( '~/test_file.bin' , 'wb' ) # Write out the packed data in binary format f . write ( data ) # Close the file f . close () Now select \u2018File->Open\u2026\u2019 within ParaView and choose test_file . bin wherever you saved it. This reader will unpack the floats and load them into a table. You can now use this data in many ways. For example, apply a \u2018Table to Uniform Grid\u2019 filter (from this repository) and set the filter parameters to the information in the print out from when you ran the script above. Once you have vtkImageData made of the data, you can apply a \u2018Warp by Scalar\u2019 filter for a fun visualization effect to see 3D ripples like the example below!","title":"Example Use"},{"location":"examples/readers-general/delimited-text/","text":"Purpose The main advantage of having this reader and using it over the default delimited text reader is that we can specify to use tab ( \\ t ) delimiters and that we deliver to the users of this repo a delimited text reader that they manipulate to work for their file format needs. About this Reader \u00b6 This reader will take in any delimited text file and make a vtkTable from it. This is not much different than the default .txt or .csv reader in ParaView, however it gives us room to use our own extensions and a little more flexibility in the structure of the files we import. Take a look at DelimitedTextReader \u2018s code docs here Down the Pipeline \u00b6 Table to Uniform Grid Reshape Table Table to Points Table to Structured Grid Normalize Array Notes: \u00b6 This reader base has also been extended to DelimitedPointsReaderBase for readers that handled delimited ASCCI text and have vtkPolyData output. Take a look at DelimitedPointsReaderBase \u2018s code docs here","title":"Delimited Text"},{"location":"examples/readers-general/delimited-text/#about-this-reader","text":"This reader will take in any delimited text file and make a vtkTable from it. This is not much different than the default .txt or .csv reader in ParaView, however it gives us room to use our own extensions and a little more flexibility in the structure of the files we import. Take a look at DelimitedTextReader \u2018s code docs here","title":"About this Reader"},{"location":"examples/readers-general/delimited-text/#down-the-pipeline","text":"Table to Uniform Grid Reshape Table Table to Points Table to Structured Grid Normalize Array","title":"Down the Pipeline"},{"location":"examples/readers-general/delimited-text/#notes","text":"This reader base has also been extended to DelimitedPointsReaderBase for readers that handled delimited ASCCI text and have vtkPolyData output. Take a look at DelimitedPointsReaderBase \u2018s code docs here","title":"Notes:"},{"location":"examples/readers-general/madagascar-ssrsf/","text":"Madagascar SSRSF \u00b6 Warning This file format reader is not fully implemeted but a working quick fix has been published so that Madagascar SSRSF data files can be imported to the ParaView pipeline. About this Reader \u00b6 This reads in float or double data that is packed into a Madagascar Single Stream RSF binary file format with a leader header. The reader ignores all of the ascii header details by searching for the sequence of three special characters: EOL EOL EOT (\\014\\014\\004) and it will treat the following binary packed data as one long array and make a vtkTable with one column of that data. The reader defaults to import as floats with native endianness. Use the Table to Uniform Grid or the Reshape Table filters to give more meaning to the data. We will later implement the ability to create a gridded volume from the header info. We chose to use a vtkTable object as the output of this reader because it gives us more flexibility in the filters we can apply to this data down the pipeline and keeps thing simple when using filters in this repository. Madagascar SSRST Format Go here to learn more about the Madagascar Single Stream RSF file format. ASCII header details are followed by data seperated by a sequence of three special characters: EOL EOL EOT (\\014\\014\\004). Down the Pipeline \u00b6 Table to Uniform Grid Reshape Table Table to Points Table to Structured Grid Normalize Array","title":"Madagascar SSRSF"},{"location":"examples/readers-general/madagascar-ssrsf/#madagascar-ssrsf","text":"Warning This file format reader is not fully implemeted but a working quick fix has been published so that Madagascar SSRSF data files can be imported to the ParaView pipeline.","title":"Madagascar SSRSF"},{"location":"examples/readers-general/madagascar-ssrsf/#about-this-reader","text":"This reads in float or double data that is packed into a Madagascar Single Stream RSF binary file format with a leader header. The reader ignores all of the ascii header details by searching for the sequence of three special characters: EOL EOL EOT (\\014\\014\\004) and it will treat the following binary packed data as one long array and make a vtkTable with one column of that data. The reader defaults to import as floats with native endianness. Use the Table to Uniform Grid or the Reshape Table filters to give more meaning to the data. We will later implement the ability to create a gridded volume from the header info. We chose to use a vtkTable object as the output of this reader because it gives us more flexibility in the filters we can apply to this data down the pipeline and keeps thing simple when using filters in this repository. Madagascar SSRST Format Go here to learn more about the Madagascar Single Stream RSF file format. ASCII header details are followed by data seperated by a sequence of three special characters: EOL EOL EOT (\\014\\014\\004).","title":"About this Reader"},{"location":"examples/readers-general/madagascar-ssrsf/#down-the-pipeline","text":"Table to Uniform Grid Reshape Table Table to Points Table to Structured Grid Normalize Array","title":"Down the Pipeline"},{"location":"examples/readers-general/xyz-reader/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"XYZ Files"},{"location":"examples/tunneling/animate-tbm/","text":"Animate Tunnel Boring Machine \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page This filter analyzes a vtkTable containing position information about a Tunnel Boring Machine (TBM). This Filter iterates over each row of the table as a timestep and uses the XYZ coordinates of a single parts of the TBM to generate a tube that represents taht part of the TBM. To create a directional vector for the length of the cylider that represents the TBM component, this filter searches for the next different point and gets a unit vector bewtween the two. Then two points are constructed in the positive and negative directions of that vector for the ends of the cylinder. This only uses rows that have a Status of 2.","title":"Animate TBM"},{"location":"examples/tunneling/animate-tbm/#animate-tunnel-boring-machine","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page This filter analyzes a vtkTable containing position information about a Tunnel Boring Machine (TBM). This Filter iterates over each row of the table as a timestep and uses the XYZ coordinates of a single parts of the TBM to generate a tube that represents taht part of the TBM. To create a directional vector for the length of the cylider that represents the TBM component, this filter searches for the next different point and gets a unit vector bewtween the two. Then two points are constructed in the positive and negative directions of that vector for the ends of the cylinder. This only uses rows that have a Status of 2.","title":"Animate Tunnel Boring Machine"},{"location":"examples/ubc/add-model/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page These filters allows you to choose a UBC model file (or time series of files) to append as an attribute to an already created grid of a UBC Mesh.","title":"Append Model"},{"location":"examples/ubc/grav-obs/","text":"Gravity Observations Reader \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Writer \u00b6 Take a look at GravObsReader \u2018s code docs here","title":"Read Gravity Observations"},{"location":"examples/ubc/grav-obs/#gravity-observations-reader","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Gravity Observations Reader"},{"location":"examples/ubc/grav-obs/#writer","text":"Take a look at GravObsReader \u2018s code docs here","title":"Writer"},{"location":"examples/ubc/mag-obs/","text":"Magnetics Observations Reader \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Writer \u00b6 Take a look at MagObsReader \u2018s code docs here","title":"Read Magnetics Observations"},{"location":"examples/ubc/mag-obs/#magnetics-observations-reader","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Magnetics Observations Reader"},{"location":"examples/ubc/mag-obs/#writer","text":"Take a look at MagObsReader \u2018s code docs here","title":"Writer"},{"location":"examples/ubc/octree/","text":"UBC OcTree Mesh \u00b6 Also see Add Model More to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page PVGeo: UBC OcTree Reader from Bane Sullivan on Vimeo . We tested this reader using the OcTree mesh found in this example on the GIFtoolsCookbook website : Mesh file: CompleteTask / octree_mesh . txt Model file: CompleteTask / active_cells_topo . txt To use the plugin: Make sure to clone/update the PVGeo repo and install if you haven\u2019t already Select File->Open\u2026 in ParaView Choose the mesh file for your OcTree (we have enabled extensions: .mesh .msh .dat .txt ) Select the PVGeo: UBC OcTree Mesh File Format reader when prompted. Optional: Click the \u2026 button next to the File Name(s) Model parameter field. You can select as many model files as you desire (each file will be appended as additional time steps for the same attribute defined by the Data Name parameter). Click Apply and wait\u2026 the load for larger OcTrees takes about 30 seconds. Example Visualization Take a look at OcTreeReader \u2018s code docs here Take a look at OcTreeAppender \u2018s code docs here","title":"Read OcTree"},{"location":"examples/ubc/octree/#ubc-octree-mesh","text":"Also see Add Model More to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page PVGeo: UBC OcTree Reader from Bane Sullivan on Vimeo . We tested this reader using the OcTree mesh found in this example on the GIFtoolsCookbook website : Mesh file: CompleteTask / octree_mesh . txt Model file: CompleteTask / active_cells_topo . txt To use the plugin: Make sure to clone/update the PVGeo repo and install if you haven\u2019t already Select File->Open\u2026 in ParaView Choose the mesh file for your OcTree (we have enabled extensions: .mesh .msh .dat .txt ) Select the PVGeo: UBC OcTree Mesh File Format reader when prompted. Optional: Click the \u2026 button next to the File Name(s) Model parameter field. You can select as many model files as you desire (each file will be appended as additional time steps for the same attribute defined by the Data Name parameter). Click Apply and wait\u2026 the load for larger OcTrees takes about 30 seconds. Example Visualization Take a look at OcTreeReader \u2018s code docs here Take a look at OcTreeAppender \u2018s code docs here","title":"UBC OcTree Mesh"},{"location":"examples/ubc/tensor-grids/","text":"UBC Tensor Meshes \u00b6 Also see Add Model About this Reader \u00b6 UBC Tensor Mesh 2D/3D models are defined using a 2-file format. The \u201cmesh\u201d file describes how the data is discretized. The \u201cmodel\u201d file lists the physical property values for all cells in a mesh. A model file is meaningless without an associated mesh file. The reader will automatically detect if the mesh is 2D or 3D and read the remainder of the data with that dimensionality assumption. If the mesh file is 2D, then then model file must also be in the 2D format (same for 3D). Full details for the UBC Tensor Mesh formats can be found here The UBC Tensor Mesh 2D/3D File Format A full explanation of the 2D mesh format can be found here and a full explanation of the 2D model format can be found here . A full explanation of the 3D mesh format can be found here and a full explanation of the 3D model format can be found here . Down the Pipeline \u00b6 UBC Add Model Normalize Array Contour Threshold Cell Data to Point Data Example Use \u00b6 For example files to use with this reader, download the example from the GIFtools Cookbook website and load the 3D mesh model into ParaView by selecting File->Open\u2026 and choose TKC_finermesh . msh as the mesh file to open using the Read UBC Mesh 2D/3D Two-File Format reader. Once the reader is on the pipeline, edit the FileName Model Parameter by choosing CompleteTask / TKCgeologyImage_mod_sus . mod as the model file. A 3D volume of data should automatically be built and visualized of the model from this example. Go ahead and slice through the model. Take a look at TensorMeshReader \u2018s code docs here Take a look at TensorMeshAppender \u2018s code docs here","title":"Read Tensor Meshes"},{"location":"examples/ubc/tensor-grids/#ubc-tensor-meshes","text":"Also see Add Model","title":"UBC Tensor Meshes"},{"location":"examples/ubc/tensor-grids/#about-this-reader","text":"UBC Tensor Mesh 2D/3D models are defined using a 2-file format. The \u201cmesh\u201d file describes how the data is discretized. The \u201cmodel\u201d file lists the physical property values for all cells in a mesh. A model file is meaningless without an associated mesh file. The reader will automatically detect if the mesh is 2D or 3D and read the remainder of the data with that dimensionality assumption. If the mesh file is 2D, then then model file must also be in the 2D format (same for 3D). Full details for the UBC Tensor Mesh formats can be found here The UBC Tensor Mesh 2D/3D File Format A full explanation of the 2D mesh format can be found here and a full explanation of the 2D model format can be found here . A full explanation of the 3D mesh format can be found here and a full explanation of the 3D model format can be found here .","title":"About this Reader"},{"location":"examples/ubc/tensor-grids/#down-the-pipeline","text":"UBC Add Model Normalize Array Contour Threshold Cell Data to Point Data","title":"Down the Pipeline"},{"location":"examples/ubc/tensor-grids/#example-use","text":"For example files to use with this reader, download the example from the GIFtools Cookbook website and load the 3D mesh model into ParaView by selecting File->Open\u2026 and choose TKC_finermesh . msh as the mesh file to open using the Read UBC Mesh 2D/3D Two-File Format reader. Once the reader is on the pipeline, edit the FileName Model Parameter by choosing CompleteTask / TKCgeologyImage_mod_sus . mod as the model file. A 3D volume of data should automatically be built and visualized of the model from this example. Go ahead and slice through the model. Take a look at TensorMeshReader \u2018s code docs here Take a look at TensorMeshAppender \u2018s code docs here","title":"Example Use"},{"location":"examples/ubc/topo/","text":"Topography Reader \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Writer \u00b6 Take a look at TopoReader \u2018s code docs here","title":"Read Topography"},{"location":"examples/ubc/topo/#topography-reader","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Topography Reader"},{"location":"examples/ubc/topo/#writer","text":"Take a look at TopoReader \u2018s code docs here","title":"Writer"},{"location":"overview/agu-2018/","text":"AGU 2018 Poster & Lightning Talk \u00b6 Are you attending AGU this year and eager to learn more about PVGeo and other open-source software in the geosciences? Then be sure to check out the two sessions on Friday for a A Tour of Open-Source Software Packages for the Geosciences ! We thought the best way to share our poster and lightning talk would be in the form of a dynamic webpage where people can stop by, interact with the visualizations, and download code to do it themselves! The Poster \u00b6 First and foremost, here\u2019s the poster (click to enlarge)! /* Style the Image Used to Trigger the Modal */ #aguImg { border-radius: 5px; cursor: pointer; transition: 0.3s; } #aguImg:hover {opacity: 0.7;} /* The Modal (background) */ .modal { display: none; /* Hidden by default */ position: fixed; /* Stay in place */ z-index: 1; /* Sit on top */ padding-top: 100px; /* Location of the box */ left: 0; top: 0; width: 100%; /* Full width */ height: 100%; /* Full height */ overflow: auto; /* Enable scroll if needed */ background-color: rgb(0,0,0); /* Fallback color */ background-color: rgba(0,0,0,0.9); /* Black w/ opacity */ } /* Modal Content (Image) */ .modal-content { margin: auto; display: block; width: 80%; max-width: 700px; } /* Caption of Modal Image (Image Text) - Same Width as the Image */ #caption { margin: auto; display: block; width: 80%; max-width: 700px; text-align: center; color: #ccc; padding: 10px 0; height: 150px; } /* Add Animation - Zoom in the Modal */ .modal-content, #caption { animation-name: zoom; animation-duration: 0.6s; } @keyframes zoom { from {transform:scale(0)} to {transform:scale(1)} } /* The Close Button */ .modal_close { position: absolute; top: 10%; right: 35px; color: #f1f1f1; font-size: 40px; font-weight: bold; transition: 0.3s; } .modal_close:hover, .modal_close:focus { color: #bbb; text-decoration: none; cursor: pointer; } /* 100% Image Width on Smaller Screens */ @media only screen and (max-width: 700px){ .modal-content { width: 100%; } } \u00d7 // Get the modal var modal = document.getElementById('aguModal'); // Get the image and insert it inside the modal - use its \"alt\" text as a caption var img = document.getElementById('aguImg'); var modalImg = document.getElementById(\"imgAGU\"); var captionText = document.getElementById(\"caption\"); img.onclick = function(){ modal.style.display = \"block\"; modalImg.src = this.src; captionText.innerHTML = this.alt; } // Get the <span> element that modal_closes the modal var span = document.getElementsByClassName(\"modal_close\")[0]; // When the user clicks on <span> (x), modal_close the modal span.onclick = function() { modal.style.display = \"none\"; } The Lightning Talk \u00b6 Info This section of the page was developed for a 5 minute lightning talk during the 2018 AGU session: A Tour of Open-Source Software Packages for the Geosciences . Moving Towards Visualization \u00b6 Typically, the 3D/4D aspects of visualization routines are separated from the processing code and software. This often requires researchers to convert their working data to other formats, creating static copies of their data files. Having static conversions of data can lead to messy working directories and trouble managing outdated data files, especially on larger projects. To mitigate this, we present PVGeo as tool to work towards dynamically linking processing to visualization, such that visualization becomes both a part of the routine for the researcher as well as a tool for post processing analysis and communication of findings. What is PVGeo? \u00b6 Python package at its core for 3D/4D geovisualization. Create compelling and integrated visualizations . Built upon VTK , a scalable and well-maintained visualization library. Extends geovisualization into ParaView , VTK.js , and Virtual Reality . Open-source : contribute on GitHub Abstract PVGeo is an open-source Python package for geoscientific visualization and analysis, harnessing an already powerful software platform: the Visualization Toolkit (VTK) and its front-end application, ParaView . The VTK software platform is well-maintained, contains an expansive set of native functionality, and provides a robust foundation for scientific visualization, yet the development of tools compatible for geoscience data and models has been limited. As a software extension package to VTK and ParaView, PVGeo addresses the lack of geoscientific compatibility by creating a framework for geovisualization. This framework is a set of tools for visually integrating geoscience data and models directly within ParaView\u2019s graphical user interface, simplifying the required routines to make compelling visualizations of geoscientific datasets. PVGeo aims to make the process of importing data into ParaView simple and fluid for users while providing a guide for contributions avoiding the typical, ambitious programming endeavor of building ParaView plugins. The PVGeo package is available for download on PyPI ( pip install PVGeo ), documented online , and open-source on GitHub for community-driven development. PVGeo Resources \u00b6 Brief demo page Slack community The code Use examples in ParaView Nitty gritty code docs Vimeo video examples What does PVGeo look like in ParaView? \u00b6 PVGeo is built for direct use within ParaView, leveraging brand new features in ParaView for Python based plugins that can leverage ParaView\u2019s powerful graphical user interface. To learn more about what PVGeo looks like within ParaView, check out the videos on the About Examples Page or other videos throughout the examples which are all posted to our Vimeo Account . What about directly in Python environments? \u00b6 Yes! PVGeo is built to work in both Python 2 and 3 across operating systems. Once PVGeo and VTK are installed to your active environment you can get to work using PVGeo directly in your workflows for analysis, data integration, and visualization! import PVGeo To learn more about using PVGeo in your Python environment, check out the psuedo-code on the About Examples Page Want to make PVGeo interoperable with another library? \u00b6 Let\u2019s do it!! You can easily extend PVGeo by diving into the source code and adding new algorithms or even entire new suites! Or simpler, you could create a plugin file that gets installed adjacent to your library that leverages PVGeo. For example, say your library has some spectacular file IO code or you can predefine processing routines in parameter files; then create a file reader algorithm that extends one of PVGeo\u2019s many base classes to parse your input data/parameter file, leverage your library for the work, then sends the results to ParaView for immediate visualization. But How? Easy! Just create a new reader algorithm and place it in a .py file like this one we built for discretize : # Import PVGeo for all its awesome super classes from PVGeo import InterfacedBaseReader from PVGeo import _helpers # Import the library you wish to leverage import discretize @smproxy.reader ( name = \"DiscretizeMeshReader\" , label = 'PVGeo: Discretize Mesh Reader' , extensions = 'json' , file_description = 'Serialized Discretize Meshes' ) class DiscretizeMeshReader ( InterfacedBaseReader ): \"\"\"A general reader for all ``discretize`` mesh objects saved to the ``.json`` serialized format\"\"\" def __init__ ( self , ** kwargs ): InterfacedBaseReader . __init__ ( self , ** kwargs ) #### Methods that will talk to the external library #### @staticmethod def _readFile ( filename ): \"\"\"Reads a mesh object from the serialized format\"\"\" return discretize . MeshIO . load_mesh ( filename ) @staticmethod def _getVTKObject ( obj ): \"\"\"Returns the mesh's proper VTK data object\"\"\" return obj . toVTK () #### Setters and Getters for the GUI #### @smproperty.xml ( _helpers . getFileReaderXml ( 'json' , readerDescription = 'Serialized Discretize Meshes' )) def AddFileName ( self , fname ): \"\"\"This enables users to select File->Open... in ParaView\"\"\" InterfacedBaseReader . AddFileName ( self , fname ) @smproperty.doublevector ( name = \"TimeDelta\" , default_values = 1.0 , panel_visibility = \"advanced\" ) def SetTimeDelta ( self , dt ): \"\"\"Allows the user to speed up/slow down the time interval if reading a time series of data\"\"\" InterfacedBaseReader . SetTimeDelta ( self , dt ) @smproperty.doublevector ( name = \"TimestepValues\" , information_only = \"1\" , si_class = \"vtkSITimeStepsProperty\" ) def GetTimestepValues ( self ): \"\"\"This is critical for registering the timesteps (if you want them)\"\"\" return InterfacedBaseReader . GetTimestepValues ( self ) How to Install PVGeo \u00b6 Eager to give PVGeo a try? The easiest way to install PVGeo is from PyPI using pip in a fresh Python 2.7 virtual environment: > pip install PVGeo Note You should follow the getting started guide ! Take aways \u00b6 Join PVGeo on Slack The slack workspace is for anyone using ParaView for geovisualization ParaView natively extends into VR (dynamically linked) VTK and ParaView are incredibly scalable PVGeo is Python based and open-source Here is an example of what can be done in ParaView via PVGeo with an interactive and shareable version below:","title":"AGU 2018"},{"location":"overview/agu-2018/#agu-2018-poster-lightning-talk","text":"Are you attending AGU this year and eager to learn more about PVGeo and other open-source software in the geosciences? Then be sure to check out the two sessions on Friday for a A Tour of Open-Source Software Packages for the Geosciences ! We thought the best way to share our poster and lightning talk would be in the form of a dynamic webpage where people can stop by, interact with the visualizations, and download code to do it themselves!","title":"AGU 2018 Poster &amp; Lightning Talk"},{"location":"overview/agu-2018/#the-poster","text":"First and foremost, here\u2019s the poster (click to enlarge)! /* Style the Image Used to Trigger the Modal */ #aguImg { border-radius: 5px; cursor: pointer; transition: 0.3s; } #aguImg:hover {opacity: 0.7;} /* The Modal (background) */ .modal { display: none; /* Hidden by default */ position: fixed; /* Stay in place */ z-index: 1; /* Sit on top */ padding-top: 100px; /* Location of the box */ left: 0; top: 0; width: 100%; /* Full width */ height: 100%; /* Full height */ overflow: auto; /* Enable scroll if needed */ background-color: rgb(0,0,0); /* Fallback color */ background-color: rgba(0,0,0,0.9); /* Black w/ opacity */ } /* Modal Content (Image) */ .modal-content { margin: auto; display: block; width: 80%; max-width: 700px; } /* Caption of Modal Image (Image Text) - Same Width as the Image */ #caption { margin: auto; display: block; width: 80%; max-width: 700px; text-align: center; color: #ccc; padding: 10px 0; height: 150px; } /* Add Animation - Zoom in the Modal */ .modal-content, #caption { animation-name: zoom; animation-duration: 0.6s; } @keyframes zoom { from {transform:scale(0)} to {transform:scale(1)} } /* The Close Button */ .modal_close { position: absolute; top: 10%; right: 35px; color: #f1f1f1; font-size: 40px; font-weight: bold; transition: 0.3s; } .modal_close:hover, .modal_close:focus { color: #bbb; text-decoration: none; cursor: pointer; } /* 100% Image Width on Smaller Screens */ @media only screen and (max-width: 700px){ .modal-content { width: 100%; } } \u00d7 // Get the modal var modal = document.getElementById('aguModal'); // Get the image and insert it inside the modal - use its \"alt\" text as a caption var img = document.getElementById('aguImg'); var modalImg = document.getElementById(\"imgAGU\"); var captionText = document.getElementById(\"caption\"); img.onclick = function(){ modal.style.display = \"block\"; modalImg.src = this.src; captionText.innerHTML = this.alt; } // Get the <span> element that modal_closes the modal var span = document.getElementsByClassName(\"modal_close\")[0]; // When the user clicks on <span> (x), modal_close the modal span.onclick = function() { modal.style.display = \"none\"; }","title":"The Poster"},{"location":"overview/agu-2018/#the-lightning-talk","text":"Info This section of the page was developed for a 5 minute lightning talk during the 2018 AGU session: A Tour of Open-Source Software Packages for the Geosciences .","title":"The Lightning Talk"},{"location":"overview/agu-2018/#moving-towards-visualization","text":"Typically, the 3D/4D aspects of visualization routines are separated from the processing code and software. This often requires researchers to convert their working data to other formats, creating static copies of their data files. Having static conversions of data can lead to messy working directories and trouble managing outdated data files, especially on larger projects. To mitigate this, we present PVGeo as tool to work towards dynamically linking processing to visualization, such that visualization becomes both a part of the routine for the researcher as well as a tool for post processing analysis and communication of findings.","title":"Moving Towards Visualization"},{"location":"overview/agu-2018/#what-is-pvgeo","text":"Python package at its core for 3D/4D geovisualization. Create compelling and integrated visualizations . Built upon VTK , a scalable and well-maintained visualization library. Extends geovisualization into ParaView , VTK.js , and Virtual Reality . Open-source : contribute on GitHub Abstract PVGeo is an open-source Python package for geoscientific visualization and analysis, harnessing an already powerful software platform: the Visualization Toolkit (VTK) and its front-end application, ParaView . The VTK software platform is well-maintained, contains an expansive set of native functionality, and provides a robust foundation for scientific visualization, yet the development of tools compatible for geoscience data and models has been limited. As a software extension package to VTK and ParaView, PVGeo addresses the lack of geoscientific compatibility by creating a framework for geovisualization. This framework is a set of tools for visually integrating geoscience data and models directly within ParaView\u2019s graphical user interface, simplifying the required routines to make compelling visualizations of geoscientific datasets. PVGeo aims to make the process of importing data into ParaView simple and fluid for users while providing a guide for contributions avoiding the typical, ambitious programming endeavor of building ParaView plugins. The PVGeo package is available for download on PyPI ( pip install PVGeo ), documented online , and open-source on GitHub for community-driven development.","title":"What is PVGeo?"},{"location":"overview/agu-2018/#pvgeo-resources","text":"Brief demo page Slack community The code Use examples in ParaView Nitty gritty code docs Vimeo video examples","title":"PVGeo Resources"},{"location":"overview/agu-2018/#what-does-pvgeo-look-like-in-paraview","text":"PVGeo is built for direct use within ParaView, leveraging brand new features in ParaView for Python based plugins that can leverage ParaView\u2019s powerful graphical user interface. To learn more about what PVGeo looks like within ParaView, check out the videos on the About Examples Page or other videos throughout the examples which are all posted to our Vimeo Account .","title":"What does PVGeo look like in ParaView?"},{"location":"overview/agu-2018/#what-about-directly-in-python-environments","text":"Yes! PVGeo is built to work in both Python 2 and 3 across operating systems. Once PVGeo and VTK are installed to your active environment you can get to work using PVGeo directly in your workflows for analysis, data integration, and visualization! import PVGeo To learn more about using PVGeo in your Python environment, check out the psuedo-code on the About Examples Page","title":"What about directly in Python environments?"},{"location":"overview/agu-2018/#want-to-make-pvgeo-interoperable-with-another-library","text":"Let\u2019s do it!! You can easily extend PVGeo by diving into the source code and adding new algorithms or even entire new suites! Or simpler, you could create a plugin file that gets installed adjacent to your library that leverages PVGeo. For example, say your library has some spectacular file IO code or you can predefine processing routines in parameter files; then create a file reader algorithm that extends one of PVGeo\u2019s many base classes to parse your input data/parameter file, leverage your library for the work, then sends the results to ParaView for immediate visualization. But How? Easy! Just create a new reader algorithm and place it in a .py file like this one we built for discretize : # Import PVGeo for all its awesome super classes from PVGeo import InterfacedBaseReader from PVGeo import _helpers # Import the library you wish to leverage import discretize @smproxy.reader ( name = \"DiscretizeMeshReader\" , label = 'PVGeo: Discretize Mesh Reader' , extensions = 'json' , file_description = 'Serialized Discretize Meshes' ) class DiscretizeMeshReader ( InterfacedBaseReader ): \"\"\"A general reader for all ``discretize`` mesh objects saved to the ``.json`` serialized format\"\"\" def __init__ ( self , ** kwargs ): InterfacedBaseReader . __init__ ( self , ** kwargs ) #### Methods that will talk to the external library #### @staticmethod def _readFile ( filename ): \"\"\"Reads a mesh object from the serialized format\"\"\" return discretize . MeshIO . load_mesh ( filename ) @staticmethod def _getVTKObject ( obj ): \"\"\"Returns the mesh's proper VTK data object\"\"\" return obj . toVTK () #### Setters and Getters for the GUI #### @smproperty.xml ( _helpers . getFileReaderXml ( 'json' , readerDescription = 'Serialized Discretize Meshes' )) def AddFileName ( self , fname ): \"\"\"This enables users to select File->Open... in ParaView\"\"\" InterfacedBaseReader . AddFileName ( self , fname ) @smproperty.doublevector ( name = \"TimeDelta\" , default_values = 1.0 , panel_visibility = \"advanced\" ) def SetTimeDelta ( self , dt ): \"\"\"Allows the user to speed up/slow down the time interval if reading a time series of data\"\"\" InterfacedBaseReader . SetTimeDelta ( self , dt ) @smproperty.doublevector ( name = \"TimestepValues\" , information_only = \"1\" , si_class = \"vtkSITimeStepsProperty\" ) def GetTimestepValues ( self ): \"\"\"This is critical for registering the timesteps (if you want them)\"\"\" return InterfacedBaseReader . GetTimestepValues ( self )","title":"Want to make PVGeo interoperable with another library?"},{"location":"overview/agu-2018/#how-to-install-pvgeo","text":"Eager to give PVGeo a try? The easiest way to install PVGeo is from PyPI using pip in a fresh Python 2.7 virtual environment: > pip install PVGeo Note You should follow the getting started guide !","title":"How to Install PVGeo"},{"location":"overview/agu-2018/#take-aways","text":"Join PVGeo on Slack The slack workspace is for anyone using ParaView for geovisualization ParaView natively extends into VR (dynamically linked) VTK and ParaView are incredibly scalable PVGeo is Python based and open-source Here is an example of what can be done in ParaView via PVGeo with an interactive and shareable version below:","title":"Take aways"},{"location":"overview/featured/","text":"Here is a list of where PVGeo has been featured or used: SimPEG Weekly Newsletter/Meeting: 13 November 2018 SimPEG Blog: May 28 \u2014 3 June 2018 Awesome Open Geoscience : as a Visualization Tool","title":"Featured"},{"location":"overview/getting-started/","text":"Info There are two ways you can use PVGeo: in any standard Python 2 or 3 environment or directly in ParaView through the graphical user interface. Be sure to follow the installation instructions for your use case. Using PVGeo in a Python Environment \u00b6 If you\u2019d like to use PVGeo in Python (>=3.6) without ParaView then simply install PVGeo to your active Python environment: Install PVGeo via pip : pip install PVGeo Having trouble installing VTK? VTK should be installed along side PVGeo: On Mac and Linux, VTK is available via pip regardless of your Python version and the build script will automatically add it. However, Windows can be tricky as the C++ backend of VTK has dependencies that are not compatible with Python 2.x on Windows. For simplicity, try Python 3.6 and install VTK from anaconda before installing PVGeo: conda install vtk Optional dependencies for more features PVGeo has a few non-required dependencies that enable more algorithms and features when available. All requirements can be found in the requirements . txt file in the repo but the needed requirements for PVGeo to work will be installed with PVGeo. Some useful dependencies: discretize : Adds algorithms that harnesses discretize \u2018s finite volume code and file IO methods. pyproj : Adds algorithms that can perform coordinate transformations Using PVGeo in ParaView \u00b6 If you\u2019d like to use PVGeo directly in ParaView\u2019s graphical user interface, you must follow the remaining steps in this section very carefully which set up an isolated Python 2.7 environment that will be shared with your installation of ParaView. Note that after you create this environment, you should leave it alone and install PVGeo using the steps in the section above for the Python environments you use everyday. A Brief Introduction to ParaView \u00b6 ParaView is an open-source platform that can visualize 2D, 3D, and 4D (time-varying) datasets. ParaView can process multiple very large data sets in parallel then later collect the results to yield a responsive graphics environment with which a user can interact. The better the processor and graphics hardware the machine or machines hosting the software, the faster and better ParaView will run. However, it can run quite well on a laptop with a standard graphics card such as a MacBook Pro. Since ParaView is an open source application, anyone can download the program and its source code for modifications. The easiest way to get started with ParaView is to download the compiled binary installers for your operating system from here . For further help, check out the documentation provided by Kitware. In particular, the two worth looking through for a quick tour of ParaView are the The ParaView Guide and The ParaView Tutorial. One is a tutorial of the ParaView software and shows the user how to create sources, apply filters, and more. The other is a guide on how to do scripting, macros, and more intense use of the application. Install ParaView \u00b6 Open the downloaded installer from ParaView\u2019s website for ParaView 5.6.x (or greater) and follow the prompts with the installer. Tour around software: Take a look at Section 2.1 of The ParaView Tutorial for details of the application\u2019s GUI environment. Chapter 2 of the tutorial as a whole does an excellent job touring the software and its workflow for those unfamiliar with the software and its general capabilities. Tip: State Files One convenient feature is to save the state of the ParaView environment. This saves all the options you selected for all the filters you applied to visualize some data. Select File->Save State\u2026 ( Note: this saves the absolute path of the files loaded into ParaView, so be sure to select Search for Files Under Directory\u2026 when opening these state files). Install PVGeo \u00b6 We highly recommend using Anaconda to manage your Python virtual environments, and we know installation via Anaconda Python distributions will work on Mac, Windows, and Linux operating systems. To begin using the PVGeo Python package, create a new virtual environment and install PVGeo through pip. $ conda create -n pvgeoenv python = 2 .7 Use Python 2.7 for linking with ParaView If you\u2019d like to link PVGeo to ParaView, you must use a Python 2.7 virtual environment. Once you create this 2.7 environment, you can opt to never use it again as it is only necessary for holding PVGeo and its dependencies for ParaView to use. If you\u2019d like to use PVGeo outside of ParaView, any version of Python will work (except Python 2.x on Windows). $ source activate pvgeoenv ( pvgeoenv ) $ pip install PVGeo Non-Windows Users \u00b6 Now you must install VTK to your virtual environment. For Linux and Mac users, simply install VTK through pip : # Now install VTK ( pvgeoenv ) $ pip install vtk Why not on Windows If you are installing PVGeo for use in ParaView, the VTK Python package is available under the ParaView installation and PVGeo will use that library. Otherwise, if you\u2019d like to use PVGeo on Windows outside of ParaView, you must use a Python >=3.6 version and install VTK through conda or pip . Install PVGeo to ParaView \u00b6 Use the latest release of ParaView PVGeo is compatible only with version 5.6.x (and higher) of ParaView. You can find the ParaView downloads page here To use the PVGeo library as plugins in ParaView, we must link the virtual environment that you installed PVGeo to ParaView\u2019s Python environment and load a series of plugin files that wrap the PVGeo code base with ParaView\u2019s Graphical User Interface. Linking PVGeo \u00b6 First, let\u2019s link PVGeo \u2018s virtual environment to ParaView by setting up a PYTHONPATH and a PV_PLUGIN_PATH environmental variables. First, retrieve the needed paths from PVGeo . Do this by executing the following from your command line: ( pvgeoenv ) $ python -m PVGeo install Having Trouble? Try executing the following command to debug the launcher creation (this will help us if you create an issue): ( pvgeoenv ) $ python -m PVGeo install echo Mac OS Users \u00b6 The above script will output the paths you need to set in the environmental variables moving forward. If you are on a Mac OS X computer, then that script will output a shell command for you to execute for the install. If you are on a Mac, run that command and skip to Loading the Plugins Windows Users \u00b6 Setting up environmental variables is a bit involved for Windows. Remember how we ran python -m PVGeo install ? Well this created a new file on your Desktop called PVGeoLauncher . bat . We will use this file to safely launch ParaView it is own environment with environmental variables appropriately set. Go to your Desktop and right-click to select New->Shortcut . Browse\u2026 to the PVGeoLauncher . bat on your Desktop. Not sure where this file is? Check the output of the install command from above. Click Next and give your shortcut a meaningful name like ParaView+PVGeo and select Finish . Now right-click that newly created shortcut and select Properties . For the Start in field, we will use the path to your ParaView installation (top-level). To discover this, go to where ParaView is installed. Likely in C : \\ Program Files and find the ParaView 5 . 6 - xxxxxx folder. Go into that folder and then copy the full path by copying the path in the navigation bar at the top of the window. Paste this path into the Start in field. Click Apply then Okay Now launch ParaView using your new shortcut! Test that the install worked: open the Python Shell and import the modules delivered in this repo by executing import PVGeo and import pvmacros . Errors should not arise but if they do, seek help via the Slack community ! Loading the Plugins \u00b6 Now you must load the plugin files through ParaView\u2019s Plugin Manager. Select Tools -> Manage Plugins then select Load New on the bottom right of the popup dialog. Navigate to the directory declared in PV_PLUGIN_PATH and load the plugins files. Note that we have included a file called PVGeo_All . py ; this will load all of PVGeo\u2019s Plugins for convenience. If you wish only to load specific suites, then load the desired suites by their individual plugin .py files. Once the plugins are loaded, expand them in the plugin manager and be sure to select Auto Load . Not sure where your PV_PLUGIN_PATH is located? Re-run the install command with an additional argument echo : ( pvgeoenv ) $ python -m PVGeo install echo Now test that the install worked by ensuring the various categories for the PVGeo filters are in the Filters menu such as PVGeo General Filters . Errors should not arise but if they do, post to the issues page and the errors will be immediately addressed. Help If an error arises or you are having trouble, feel free to join the PVGeo community on Slack and ask for help: You can also post to the issues page if you think you are encountering a bug. Using Outside Modules in ParaView \u00b6 If you installed PVGeo according to the instructions above, then any Python package installed through pip/conda in that virtual environment will be accessible in ParaView. For some further reading on using virtual environments with ParaView, see this blog post . Update PVGeo \u00b6 Use pip to update PVGeo in your python environment(s): ( pvgeoenv ) $ pip install --upgrade PVGeo","title":"Getting Started"},{"location":"overview/getting-started/#using-pvgeo-in-a-python-environment","text":"If you\u2019d like to use PVGeo in Python (>=3.6) without ParaView then simply install PVGeo to your active Python environment: Install PVGeo via pip : pip install PVGeo Having trouble installing VTK? VTK should be installed along side PVGeo: On Mac and Linux, VTK is available via pip regardless of your Python version and the build script will automatically add it. However, Windows can be tricky as the C++ backend of VTK has dependencies that are not compatible with Python 2.x on Windows. For simplicity, try Python 3.6 and install VTK from anaconda before installing PVGeo: conda install vtk Optional dependencies for more features PVGeo has a few non-required dependencies that enable more algorithms and features when available. All requirements can be found in the requirements . txt file in the repo but the needed requirements for PVGeo to work will be installed with PVGeo. Some useful dependencies: discretize : Adds algorithms that harnesses discretize \u2018s finite volume code and file IO methods. pyproj : Adds algorithms that can perform coordinate transformations","title":"Using PVGeo in a Python Environment"},{"location":"overview/getting-started/#using-pvgeo-in-paraview","text":"If you\u2019d like to use PVGeo directly in ParaView\u2019s graphical user interface, you must follow the remaining steps in this section very carefully which set up an isolated Python 2.7 environment that will be shared with your installation of ParaView. Note that after you create this environment, you should leave it alone and install PVGeo using the steps in the section above for the Python environments you use everyday.","title":"Using PVGeo in ParaView"},{"location":"overview/getting-started/#a-brief-introduction-to-paraview","text":"ParaView is an open-source platform that can visualize 2D, 3D, and 4D (time-varying) datasets. ParaView can process multiple very large data sets in parallel then later collect the results to yield a responsive graphics environment with which a user can interact. The better the processor and graphics hardware the machine or machines hosting the software, the faster and better ParaView will run. However, it can run quite well on a laptop with a standard graphics card such as a MacBook Pro. Since ParaView is an open source application, anyone can download the program and its source code for modifications. The easiest way to get started with ParaView is to download the compiled binary installers for your operating system from here . For further help, check out the documentation provided by Kitware. In particular, the two worth looking through for a quick tour of ParaView are the The ParaView Guide and The ParaView Tutorial. One is a tutorial of the ParaView software and shows the user how to create sources, apply filters, and more. The other is a guide on how to do scripting, macros, and more intense use of the application.","title":"A Brief Introduction to ParaView"},{"location":"overview/getting-started/#install-paraview","text":"Open the downloaded installer from ParaView\u2019s website for ParaView 5.6.x (or greater) and follow the prompts with the installer. Tour around software: Take a look at Section 2.1 of The ParaView Tutorial for details of the application\u2019s GUI environment. Chapter 2 of the tutorial as a whole does an excellent job touring the software and its workflow for those unfamiliar with the software and its general capabilities. Tip: State Files One convenient feature is to save the state of the ParaView environment. This saves all the options you selected for all the filters you applied to visualize some data. Select File->Save State\u2026 ( Note: this saves the absolute path of the files loaded into ParaView, so be sure to select Search for Files Under Directory\u2026 when opening these state files).","title":"Install ParaView"},{"location":"overview/getting-started/#install-pvgeo","text":"We highly recommend using Anaconda to manage your Python virtual environments, and we know installation via Anaconda Python distributions will work on Mac, Windows, and Linux operating systems. To begin using the PVGeo Python package, create a new virtual environment and install PVGeo through pip. $ conda create -n pvgeoenv python = 2 .7 Use Python 2.7 for linking with ParaView If you\u2019d like to link PVGeo to ParaView, you must use a Python 2.7 virtual environment. Once you create this 2.7 environment, you can opt to never use it again as it is only necessary for holding PVGeo and its dependencies for ParaView to use. If you\u2019d like to use PVGeo outside of ParaView, any version of Python will work (except Python 2.x on Windows). $ source activate pvgeoenv ( pvgeoenv ) $ pip install PVGeo","title":"Install PVGeo"},{"location":"overview/getting-started/#non-windows-users","text":"Now you must install VTK to your virtual environment. For Linux and Mac users, simply install VTK through pip : # Now install VTK ( pvgeoenv ) $ pip install vtk Why not on Windows If you are installing PVGeo for use in ParaView, the VTK Python package is available under the ParaView installation and PVGeo will use that library. Otherwise, if you\u2019d like to use PVGeo on Windows outside of ParaView, you must use a Python >=3.6 version and install VTK through conda or pip .","title":"Non-Windows Users"},{"location":"overview/getting-started/#install-pvgeo-to-paraview","text":"Use the latest release of ParaView PVGeo is compatible only with version 5.6.x (and higher) of ParaView. You can find the ParaView downloads page here To use the PVGeo library as plugins in ParaView, we must link the virtual environment that you installed PVGeo to ParaView\u2019s Python environment and load a series of plugin files that wrap the PVGeo code base with ParaView\u2019s Graphical User Interface.","title":"Install PVGeo to ParaView"},{"location":"overview/getting-started/#linking-pvgeo","text":"First, let\u2019s link PVGeo \u2018s virtual environment to ParaView by setting up a PYTHONPATH and a PV_PLUGIN_PATH environmental variables. First, retrieve the needed paths from PVGeo . Do this by executing the following from your command line: ( pvgeoenv ) $ python -m PVGeo install Having Trouble? Try executing the following command to debug the launcher creation (this will help us if you create an issue): ( pvgeoenv ) $ python -m PVGeo install echo","title":"Linking PVGeo"},{"location":"overview/getting-started/#mac-os-users","text":"The above script will output the paths you need to set in the environmental variables moving forward. If you are on a Mac OS X computer, then that script will output a shell command for you to execute for the install. If you are on a Mac, run that command and skip to Loading the Plugins","title":"Mac OS Users"},{"location":"overview/getting-started/#windows-users","text":"Setting up environmental variables is a bit involved for Windows. Remember how we ran python -m PVGeo install ? Well this created a new file on your Desktop called PVGeoLauncher . bat . We will use this file to safely launch ParaView it is own environment with environmental variables appropriately set. Go to your Desktop and right-click to select New->Shortcut . Browse\u2026 to the PVGeoLauncher . bat on your Desktop. Not sure where this file is? Check the output of the install command from above. Click Next and give your shortcut a meaningful name like ParaView+PVGeo and select Finish . Now right-click that newly created shortcut and select Properties . For the Start in field, we will use the path to your ParaView installation (top-level). To discover this, go to where ParaView is installed. Likely in C : \\ Program Files and find the ParaView 5 . 6 - xxxxxx folder. Go into that folder and then copy the full path by copying the path in the navigation bar at the top of the window. Paste this path into the Start in field. Click Apply then Okay Now launch ParaView using your new shortcut! Test that the install worked: open the Python Shell and import the modules delivered in this repo by executing import PVGeo and import pvmacros . Errors should not arise but if they do, seek help via the Slack community !","title":"Windows Users"},{"location":"overview/getting-started/#loading-the-plugins","text":"Now you must load the plugin files through ParaView\u2019s Plugin Manager. Select Tools -> Manage Plugins then select Load New on the bottom right of the popup dialog. Navigate to the directory declared in PV_PLUGIN_PATH and load the plugins files. Note that we have included a file called PVGeo_All . py ; this will load all of PVGeo\u2019s Plugins for convenience. If you wish only to load specific suites, then load the desired suites by their individual plugin .py files. Once the plugins are loaded, expand them in the plugin manager and be sure to select Auto Load . Not sure where your PV_PLUGIN_PATH is located? Re-run the install command with an additional argument echo : ( pvgeoenv ) $ python -m PVGeo install echo Now test that the install worked by ensuring the various categories for the PVGeo filters are in the Filters menu such as PVGeo General Filters . Errors should not arise but if they do, post to the issues page and the errors will be immediately addressed. Help If an error arises or you are having trouble, feel free to join the PVGeo community on Slack and ask for help: You can also post to the issues page if you think you are encountering a bug.","title":"Loading the Plugins"},{"location":"overview/getting-started/#using-outside-modules-in-paraview","text":"If you installed PVGeo according to the instructions above, then any Python package installed through pip/conda in that virtual environment will be accessible in ParaView. For some further reading on using virtual environments with ParaView, see this blog post .","title":"Using Outside Modules in ParaView"},{"location":"overview/getting-started/#update-pvgeo","text":"Use pip to update PVGeo in your python environment(s): ( pvgeoenv ) $ pip install --upgrade PVGeo","title":"Update PVGeo"},{"location":"overview/upcoming/","text":"Here is a list of features that are shortly coming to this repo.We will try to regularly update this page; for a more update view of our activity, please check out the different projects on the GitHub page here . More documentation is soon to come. We want to do it right: with tutorials, example data, and detailed justification for need and use of each reader, filter, and macro. Suggestions? We need your suggestions for what kinds of file format readers to make as well as ideas for filters to meet your data needs. Post on the issues page on GitHub as a feature request. Don\u2019t have a GitHub account but still have ideas or questions? Post a comment at the bottom of this page or join the PVGeo community discussions on Slack . Readers \u00b6 Open Mining Format: Project files containg all data types. More info found here . NOTE: We opened a pull request for omf that needs to be addressed and finished before further progress on this. Well logs: Readers for common formats (LAS) and easy ways to project well logs in XYZ space. Details here ESRI shape files: Details here and here ESRI Grid : 2D ESRI ASCII and binary grid data files UBC Tensor Meshes : both 2D and 3D implemented with time series capabilities UBC OcTree Mesh : fully implemented but we need test mesh-model file pairs with time series capabilities Filters \u00b6 Transpose Grid: Transpose or swap axes of grid data sets (vtkImageData and vtkRectilinearGrid) Extract Array: This will allow you to extract any array from any data structure as a vtkTable . Reshape Table: Adding ability to reshape using Fortran ordering on the currently available filter. Voxelize Points : This will take a point set and generate voxels of some specified size at every point or estimate an appropriate voxel size if the points are uniformly spaced. Many Slices Along Points : Generate many slices of dataset along a line at every point on that line (normal is the vector from that point to the next). Append Model to UBC Mesh : This will load a model file and tag it on to vtkStructuredGrid loaded from a UBC Mesh reader. Think of it as appending models as attributes to the 3D mesh. Macros in pvmacros \u00b6 Save screenshots in isometric views, side, top, etc. in an automated fashion Export a scene to a shareable 3D format Scripts \u00b6 How to start making your own scripts (tips, tricks, and general advice) A few sample scripts to set up tutorial environments. Examples and Other Docs \u00b6 Tutorials for each filter/reader/macro will be in their respective documentation. How to send data scenes made using the Readers, Filters, and Macros in this repository over to the Virtual Reality build of ParaView How to build your own plugins using this project\u2019s framework and build scripts Importing DEM topography (with/without satellite imagery) Slicing/cropping a data scene through all components/datasets (managing links)","title":"Upcoming"},{"location":"overview/upcoming/#readers","text":"Open Mining Format: Project files containg all data types. More info found here . NOTE: We opened a pull request for omf that needs to be addressed and finished before further progress on this. Well logs: Readers for common formats (LAS) and easy ways to project well logs in XYZ space. Details here ESRI shape files: Details here and here ESRI Grid : 2D ESRI ASCII and binary grid data files UBC Tensor Meshes : both 2D and 3D implemented with time series capabilities UBC OcTree Mesh : fully implemented but we need test mesh-model file pairs with time series capabilities","title":"Readers"},{"location":"overview/upcoming/#filters","text":"Transpose Grid: Transpose or swap axes of grid data sets (vtkImageData and vtkRectilinearGrid) Extract Array: This will allow you to extract any array from any data structure as a vtkTable . Reshape Table: Adding ability to reshape using Fortran ordering on the currently available filter. Voxelize Points : This will take a point set and generate voxels of some specified size at every point or estimate an appropriate voxel size if the points are uniformly spaced. Many Slices Along Points : Generate many slices of dataset along a line at every point on that line (normal is the vector from that point to the next). Append Model to UBC Mesh : This will load a model file and tag it on to vtkStructuredGrid loaded from a UBC Mesh reader. Think of it as appending models as attributes to the 3D mesh.","title":"Filters"},{"location":"overview/upcoming/#macros-in-pvmacros","text":"Save screenshots in isometric views, side, top, etc. in an automated fashion Export a scene to a shareable 3D format","title":"Macros in pvmacros"},{"location":"overview/upcoming/#scripts","text":"How to start making your own scripts (tips, tricks, and general advice) A few sample scripts to set up tutorial environments.","title":"Scripts"},{"location":"overview/upcoming/#examples-and-other-docs","text":"Tutorials for each filter/reader/macro will be in their respective documentation. How to send data scenes made using the Readers, Filters, and Macros in this repository over to the Virtual Reality build of ParaView How to build your own plugins using this project\u2019s framework and build scripts Importing DEM topography (with/without satellite imagery) Slicing/cropping a data scene through all components/datasets (managing links)","title":"Examples and Other Docs"},{"location":"overview/why-pvgeo/","text":"Why PVGeo? \u00b6 PVGeo is an open-source Python package for geoscientific visualization and analysis harnessing an already powerful software platform: the Visualization Toolkit (VTK) and its front-end application, ParaView . The VTK software platform is well-maintained, contains an expansive set of native functionality, and provides a robust foundation for scientific visualization, yet the development of tools compatible for geoscience data and models has been very limited. As a software extension package to VTK and ParaView, PVGeo addresses the lack of geoscientific compatibility by creating a framework for geo-visualization. This framework is a set of tools for visually integrating geoscience data and models directly within ParaView\u2019s graphical user interface, simplifying the required routines to make compelling visualizations of geoscientific datasets. The PVGeo package is available for download on PyPI ( pip install PVGeo ), documented on this website, and open-source on GitHub for community-driven developments. About the Project \u00b6 This code base is full of plugins and macros for the open-source, multi-platform, data analysis, and visualization application ParaView by Kitware. These plugins are tailored to the visualization of spatially referenced data in the geosciences, especially geophysics. The overarching goal of this project is to develop set of codes to visually integrate post-processed data for more intuitive visualization. To make more intuitive visualizations, we think it is necessary to reference data in relation to features like topography, well locations, survey points, or other known features that are easier to spatially grasp. This code base deploys tools to perform post-processing visual analysis and interpretation of geophysical data and models and we hope that geophysicists will gain an ability to represent their 3D spatially referenced data intuitively to interested parties and stakeholders. By integrating the visualization of various data, and creating a sort of visual data fusion, interested parties will gain insight into the value of the information in their models. Through visual integration, we try to mimic the reality of the space in which data was acquired so that it will hold meaning to anyone that immerses into the visualization regardless of background.","title":"Why PVGeo?"},{"location":"overview/why-pvgeo/#why-pvgeo","text":"PVGeo is an open-source Python package for geoscientific visualization and analysis harnessing an already powerful software platform: the Visualization Toolkit (VTK) and its front-end application, ParaView . The VTK software platform is well-maintained, contains an expansive set of native functionality, and provides a robust foundation for scientific visualization, yet the development of tools compatible for geoscience data and models has been very limited. As a software extension package to VTK and ParaView, PVGeo addresses the lack of geoscientific compatibility by creating a framework for geo-visualization. This framework is a set of tools for visually integrating geoscience data and models directly within ParaView\u2019s graphical user interface, simplifying the required routines to make compelling visualizations of geoscientific datasets. The PVGeo package is available for download on PyPI ( pip install PVGeo ), documented on this website, and open-source on GitHub for community-driven developments.","title":"Why PVGeo?"},{"location":"overview/why-pvgeo/#about-the-project","text":"This code base is full of plugins and macros for the open-source, multi-platform, data analysis, and visualization application ParaView by Kitware. These plugins are tailored to the visualization of spatially referenced data in the geosciences, especially geophysics. The overarching goal of this project is to develop set of codes to visually integrate post-processed data for more intuitive visualization. To make more intuitive visualizations, we think it is necessary to reference data in relation to features like topography, well locations, survey points, or other known features that are easier to spatially grasp. This code base deploys tools to perform post-processing visual analysis and interpretation of geophysical data and models and we hope that geophysicists will gain an ability to represent their 3D spatially referenced data intuitively to interested parties and stakeholders. By integrating the visualization of various data, and creating a sort of visual data fusion, interested parties will gain insight into the value of the information in their models. Through visual integration, we try to mimic the reality of the space in which data was acquired so that it will hold meaning to anyone that immerses into the visualization regardless of background.","title":"About the Project"},{"location":"pvmacros/about-pvmacros/","text":"About pvmacros \u00b6 Further description to come! Current content is deprecated. There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page We will from now on refer to macros as a set of standard codes that can be used regardless of data sets or scenes in ParaView. ParaView\u2019s sense of macro is not robust enough for us so that we will be referring to traditional macros in ParaView as \u2018scripts\u2019 from here on. Scripts are used on specific sets of data whereas macros can be used on any set of data. For details on scripts, please look here . Macros \u00b6 Macros, all of the pvmacros module, are standard codes that can be used regardless of data sets or scenes in ParaView. These codes complete tedious or recurring tasks either in ParaView\u2019s GUI or ParaView\u2019s batch processing environment. We will use macros to complete everyday tasks like saving screenshots of isometric views of a data scene or tedious tasks like making many slices of a single data set along a line.","title":"About pvmacros"},{"location":"pvmacros/about-pvmacros/#about-pvmacros","text":"Further description to come! Current content is deprecated. There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page We will from now on refer to macros as a set of standard codes that can be used regardless of data sets or scenes in ParaView. ParaView\u2019s sense of macro is not robust enough for us so that we will be referring to traditional macros in ParaView as \u2018scripts\u2019 from here on. Scripts are used on specific sets of data whereas macros can be used on any set of data. For details on scripts, please look here .","title":"About pvmacros"},{"location":"pvmacros/about-pvmacros/#macros","text":"Macros, all of the pvmacros module, are standard codes that can be used regardless of data sets or scenes in ParaView. These codes complete tedious or recurring tasks either in ParaView\u2019s GUI or ParaView\u2019s batch processing environment. We will use macros to complete everyday tasks like saving screenshots of isometric views of a data scene or tedious tasks like making many slices of a single data set along a line.","title":"Macros"},{"location":"pvmacros/export/exportvtkjs/","text":"Purpose On this page, we demonstrate how to quickly share a 3D rendering of your ParaView visualizations with anyone who has access to the internet so that that can explore the whole scene in a dynamic manner. Motivation \u00b6 In order to effectively communicate our geoscientific findings, we often need to share our 3D visualizations with interested stakeholders. These interested parties are likely not going to have ParaView or other visualization software at hand. Thus we desire to have a means to export our complex visualizations in ParaView to a simple, shareable format that anyone can view. To accomplish this, we will take advantage of vtk.js and its standalone web viewer for vtk.js formats. Would not it be great to send your client or interested parties an interactive 3D scene of your Geophysical findings like the example below? VTK.js \u00b6 vtk.js is a rendering library made for scientific visualization on the web. This code base brings high performance rendering into anyone\u2019s web browser. This library allows us to export complex scenes from ParaView and share them with anyone that has a web browser like Safari or Google Chrome. The vtk.js library has an open-source standalone scene viewer which they have a nice demo for here . The first link can either be downloaded as an HTML file to be ran locally, or you can go to that link and run from the vtk.js server. vtk.js also published a scene export macro for ParaView that compresses a data scene in ParaView to a shareable format for viewing on the web. The macro from the vtk.js library can be found here but we also deploy an updated (we think more robust) version of this export macro in the sub-module export of our Python module pvmacros . Demo Shareable Format \u00b6 Here are some samples to demonstrate the web viewer which we host on viewer.vtki.org . We have included a few of our scenes and one of the vtk.js sample scenes for you to demo: Fluvial Channels Volcano Ripple Tunnels vtk.js Sample Scene Example Use \u00b6 First, make a complex scene in ParaView that you might like to share with someone. Now that you have your scene loaded, open the python shell from\u2019View->Python Shell\u2019 (or \u2018Tools->Python Shell\u2019 depending on your ParaView version) within ParaView. From here, import our Python module delivered in the repository called pvmacros . From the export sub-module, there is a function called def exportVTKjs () which takes two optional arguments ( FileName string and compress boolean). Execute this function and note the output text as it will describe where the exported scene was saved. ## Import our ParaView Macros module: import pvmacros as pvm ## Now run the exportVTKjs script from the export sub-module pvm . export . exportVTKjs ( FileName = 'test_export' ) Now open the standalone web viewer by opening viewer.vtki.org . Select the exported scene as the input file for the web viewer from where you saved it (should be under ~/ Dropbox / PVGeo_vtkjs / ). The export macro should have printed out the location of the saved scene in the Python Shell. Help If you have trouble post on our issues page or read the vtk.js documentation here How to Share \u00b6 To share these exported scenes with non-technical stakeholders, we recommend the following processes: Quick and Easy \u00b6 Create your scene and export to the vtk.js format (follow process above) Quality control your visualization by viewing in web browser yourself (follow process above) Send an email with your visualization ( * . vtkjs file) and something along the lines of: Check out the data scene/model by downloading the attached file. Then go to the link below and open that downloaded file. http://viewer.vtki.org/ A Bit More Robust \u00b6 Sometimes we might want to give someone a direct link to the web visualization so all they have to do is open the link on any device and they can see our visualization. Here is a method to share scenes that have a slightly easier process of viewing the file for the end user and will handle the case for mobile platforms. Unfortunately, making the experience for the end user simple means making your experience a bit more complicated. You will need to host your file on a web service like GitHub or Dropbox (we have been unsuccessful in getting Google Drive to work) . Then get a public link to the * . vtkjs file on that web service and append it to the web viewer URL. We have created a Python script to generate these links for you if you are sharing your data file on either Dropbox or GitHub. The script is delivered in the repository and can also be found here . The easiest way that we have found is to share the files on Dropbox. Use the desktop client for Dropbox and right-click your exported * . vtkjs file and select \u201cCopy Dropbox Link.\u201d Once you have that link, use the this script on your URLs in this manner: ## Usage: python get_vtkjs_url.py <web file host> <file link> ## Dropbox example: python get_vtkjs_url.py dropbox \"https://www.dropbox.com/s/6m5ttdbv5bf4ngj/ripple.vtkjs?dl=0\" PVGeo Export Demo from Bane Sullivan on Vimeo .","title":"Export as VTKjs"},{"location":"pvmacros/export/exportvtkjs/#motivation","text":"In order to effectively communicate our geoscientific findings, we often need to share our 3D visualizations with interested stakeholders. These interested parties are likely not going to have ParaView or other visualization software at hand. Thus we desire to have a means to export our complex visualizations in ParaView to a simple, shareable format that anyone can view. To accomplish this, we will take advantage of vtk.js and its standalone web viewer for vtk.js formats. Would not it be great to send your client or interested parties an interactive 3D scene of your Geophysical findings like the example below?","title":"Motivation"},{"location":"pvmacros/export/exportvtkjs/#vtkjs","text":"vtk.js is a rendering library made for scientific visualization on the web. This code base brings high performance rendering into anyone\u2019s web browser. This library allows us to export complex scenes from ParaView and share them with anyone that has a web browser like Safari or Google Chrome. The vtk.js library has an open-source standalone scene viewer which they have a nice demo for here . The first link can either be downloaded as an HTML file to be ran locally, or you can go to that link and run from the vtk.js server. vtk.js also published a scene export macro for ParaView that compresses a data scene in ParaView to a shareable format for viewing on the web. The macro from the vtk.js library can be found here but we also deploy an updated (we think more robust) version of this export macro in the sub-module export of our Python module pvmacros .","title":"VTK.js"},{"location":"pvmacros/export/exportvtkjs/#demo-shareable-format","text":"Here are some samples to demonstrate the web viewer which we host on viewer.vtki.org . We have included a few of our scenes and one of the vtk.js sample scenes for you to demo: Fluvial Channels Volcano Ripple Tunnels vtk.js Sample Scene","title":"Demo Shareable Format"},{"location":"pvmacros/export/exportvtkjs/#example-use","text":"First, make a complex scene in ParaView that you might like to share with someone. Now that you have your scene loaded, open the python shell from\u2019View->Python Shell\u2019 (or \u2018Tools->Python Shell\u2019 depending on your ParaView version) within ParaView. From here, import our Python module delivered in the repository called pvmacros . From the export sub-module, there is a function called def exportVTKjs () which takes two optional arguments ( FileName string and compress boolean). Execute this function and note the output text as it will describe where the exported scene was saved. ## Import our ParaView Macros module: import pvmacros as pvm ## Now run the exportVTKjs script from the export sub-module pvm . export . exportVTKjs ( FileName = 'test_export' ) Now open the standalone web viewer by opening viewer.vtki.org . Select the exported scene as the input file for the web viewer from where you saved it (should be under ~/ Dropbox / PVGeo_vtkjs / ). The export macro should have printed out the location of the saved scene in the Python Shell. Help If you have trouble post on our issues page or read the vtk.js documentation here","title":"Example Use"},{"location":"pvmacros/export/exportvtkjs/#how-to-share","text":"To share these exported scenes with non-technical stakeholders, we recommend the following processes:","title":"How to Share"},{"location":"pvmacros/export/exportvtkjs/#quick-and-easy","text":"Create your scene and export to the vtk.js format (follow process above) Quality control your visualization by viewing in web browser yourself (follow process above) Send an email with your visualization ( * . vtkjs file) and something along the lines of: Check out the data scene/model by downloading the attached file. Then go to the link below and open that downloaded file. http://viewer.vtki.org/","title":"Quick and Easy"},{"location":"pvmacros/export/exportvtkjs/#a-bit-more-robust","text":"Sometimes we might want to give someone a direct link to the web visualization so all they have to do is open the link on any device and they can see our visualization. Here is a method to share scenes that have a slightly easier process of viewing the file for the end user and will handle the case for mobile platforms. Unfortunately, making the experience for the end user simple means making your experience a bit more complicated. You will need to host your file on a web service like GitHub or Dropbox (we have been unsuccessful in getting Google Drive to work) . Then get a public link to the * . vtkjs file on that web service and append it to the web viewer URL. We have created a Python script to generate these links for you if you are sharing your data file on either Dropbox or GitHub. The script is delivered in the repository and can also be found here . The easiest way that we have found is to share the files on Dropbox. Use the desktop client for Dropbox and right-click your exported * . vtkjs file and select \u201cCopy Dropbox Link.\u201d Once you have that link, use the this script on your URLs in this manner: ## Usage: python get_vtkjs_url.py <web file host> <file link> ## Dropbox example: python get_vtkjs_url.py dropbox \"https://www.dropbox.com/s/6m5ttdbv5bf4ngj/ripple.vtkjs?dl=0\" PVGeo Export Demo from Bane Sullivan on Vimeo .","title":"A Bit More Robust"},{"location":"pvmacros/vis/camera/","text":"","title":"Camera"},{"location":"resources/edit-axes/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Editing the Axes"},{"location":"resources/edit-render-view/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Editing the Render View"},{"location":"resources/references/","text":"External References \u00b6 Here we have compiled a list of resources and reference material for learning how to use VTK in a Python environment and learning the ParaView interface. VTK & Python \u00b6 Improved VTK \u2013 numpy integration | Kitware Blog IPython Notebook & VTK | PyScience A VTK pipeline primer (part 1) | Kitware Blog vtkPythonAlgorithm is great | Kitware Blog Developing HDF5 readers using vtkPythonAlgorithm | Kitware Blog VTK/Tutorials/New Pipeline - KitwarePublic VTK Python Examples Create virtual environments for python with conda ParaView/Simple ParaView 3 Python Filters - KitwarePublic Streaming in VTK : Time | The Kitware Blog ParaView \u00b6 The ParaView Guide ParaViewWeb: Using ParaView\u2019s Visualization and Data Analysis Capabilities within Web Applications | Kitware Blog Proxy Hints And Annotations ServerManager XML Hints","title":"External References"},{"location":"resources/references/#external-references","text":"Here we have compiled a list of resources and reference material for learning how to use VTK in a Python environment and learning the ParaView interface.","title":"External References"},{"location":"resources/references/#vtk-python","text":"Improved VTK \u2013 numpy integration | Kitware Blog IPython Notebook & VTK | PyScience A VTK pipeline primer (part 1) | Kitware Blog vtkPythonAlgorithm is great | Kitware Blog Developing HDF5 readers using vtkPythonAlgorithm | Kitware Blog VTK/Tutorials/New Pipeline - KitwarePublic VTK Python Examples Create virtual environments for python with conda ParaView/Simple ParaView 3 Python Filters - KitwarePublic Streaming in VTK : Time | The Kitware Blog","title":"VTK &amp; Python"},{"location":"resources/references/#paraview","text":"The ParaView Guide ParaViewWeb: Using ParaView\u2019s Visualization and Data Analysis Capabilities within Web Applications | Kitware Blog Proxy Hints And Annotations ServerManager XML Hints","title":"ParaView"},{"location":"resources/save-camera-locations/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Save Camera Views"},{"location":"resources/understand-vtk/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Understand VTK Data Types"},{"location":"scripts/about-scripts/","text":"Scripts \u00b6 Scripts are Python codes we will use for tasks like loading scenes and for applying several macros at once for a specific project. It is often helpful to set up a script for a project so that you can quickly run all the visualization processing at once each time you update your model files or create new versions of your data. Scripts are used on specific sets of data whereas macros can be used on any set of data. For details on macros, please look here . How to Run Scripts \u00b6 Use the Python Shell from \u2018View->Python Shell\u2019 (or \u2018Tools->Python Shell\u2019 depending on your ParaView version) in the ParaView GUI. Do not import scripts as macros in ParaView as they become static in the ParaView GUI and make managing/changing quite difficult. To use scripts in the batch processing environment, use the pvpython program delivered in ParaView. On my OS X operating system it is under the Applications / ParaView / Contents / bin / pvpython . More info on all of this to come! To simply run the scripts in this repo, edit the script files under the scripts / directory for your use, then run them in ParaView by selecting \u2018View->Python Shell\u2019 (or \u2018Tools->Python Shell\u2019 depending on your ParaView version) then click \u2018Run Script\u2019. Navigate to the scripts / directory in this repo and select the script you desire to use. Make Your Own Scripts \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Using the Trace Tool \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page Using PVPython \u00b6 Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"About Scripts"},{"location":"scripts/about-scripts/#scripts","text":"Scripts are Python codes we will use for tasks like loading scenes and for applying several macros at once for a specific project. It is often helpful to set up a script for a project so that you can quickly run all the visualization processing at once each time you update your model files or create new versions of your data. Scripts are used on specific sets of data whereas macros can be used on any set of data. For details on macros, please look here .","title":"Scripts"},{"location":"scripts/about-scripts/#how-to-run-scripts","text":"Use the Python Shell from \u2018View->Python Shell\u2019 (or \u2018Tools->Python Shell\u2019 depending on your ParaView version) in the ParaView GUI. Do not import scripts as macros in ParaView as they become static in the ParaView GUI and make managing/changing quite difficult. To use scripts in the batch processing environment, use the pvpython program delivered in ParaView. On my OS X operating system it is under the Applications / ParaView / Contents / bin / pvpython . More info on all of this to come! To simply run the scripts in this repo, edit the script files under the scripts / directory for your use, then run them in ParaView by selecting \u2018View->Python Shell\u2019 (or \u2018Tools->Python Shell\u2019 depending on your ParaView version) then click \u2018Run Script\u2019. Navigate to the scripts / directory in this repo and select the script you desire to use.","title":"How to Run Scripts"},{"location":"scripts/about-scripts/#make-your-own-scripts","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Make Your Own Scripts"},{"location":"scripts/about-scripts/#using-the-trace-tool","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Using the Trace Tool"},{"location":"scripts/about-scripts/#using-pvpython","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page","title":"Using PVPython"},{"location":"scripts/example-script/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page {py:scripts/sample_script.py?1 4 7}","title":"Example Script"},{"location":"virtual-reality/entering-virtual-reality/","text":"Description to come! There are a lot of pages in the documentation and we are trying to fill all content as soon as possible. Stay tuned for updates to this page ParaView+PVGeo to Virtual Reality from PVGeo Support Team on Vimeo . VR Demo in ParaView from Bane Sullivan on Vimeo .","title":"Entering Virtual Reality"}]}